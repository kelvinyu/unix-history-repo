(File common1.l)
(xcons lambda cons)
(vil nlambda quote exvi)
(vi nlambda quote exvi)
(substequal lambda cdr car substequal cons atom equal cond)
(substeq lambda cdr car substeq cons atom eq cond)
(subst lambda substequal substeq symbolp cond)
(sublishelp lambda cons and or not car sublishelp cdr list assoc setq atom cond let)
(sublis lambda car sublishelp cdr assoc setq atom cond let)
(exchange2 (lambda . local) car cdr rplaca cadr setq prog)
(sortcarhelp lambda sortcarhelp exchange2 Internal-bcdcall getdisc quote eq bcdp setq cxr getd symbolp and caar caadr funcall cdr null cond)
(sortcar lambda |1+| sortcarhelp greaterp do length setq return null cond prog)
(mergelists lambda go Internal-bcdcall getdisc quote eq bcdp cxr getd symbolp and car funcall cdr return rplacd null cond cons setq prog)
(splitlist lambda cons return sub1 rplacd setq bigp not and zerop cdr null or do prog)
(sortmerge lambda prog1 rplaca Internal-bcdcall getdisc quote bcdp cxr getd symbolp and cadr funcall not eq null do cdr car sortmerge mergelists return quotient splitlist setq greaterp cond prog)
(sort lambda length sortmerge quote cond setq)
(sload lambda eval cadr print dtpr close eq read do gensym return terpr patom infile setq cond prog)
(shell lambda cons ncons apply setq flatc lessp cond quote getenv)
(reverse lambda cdr car cons do null cond)
(prog1 lexpr arg)
(princ lexpr return not cdr do cadr princ patom cddr null car quote and dtpr arg setq eq cond prog)
(plusp lambda greaterp)
(oddp lambda bigp cdr null and fixnum-BitAndNot boole zerop not cond)
(min lexpr |1-| setq cdr cond lessp arg do)
(member lambda cdr return car equal cond null do)
(makhunk lambda quote apply |1+| cdr *rplacx eq =& do *makhunk return minusp haulong |1-| error greaterp numberp cond setq prog)
(macroexpand lambda cddr cadr go apply eq nreverse macroexpand null cdr liszt-internal-do mapcar cons memq dtpr quote arrayp getdisc bcdp cxr getd setq let car return atom cond prog)
(list-to-bignum lambda cdr list-to-bignum car scons cond)
(length lambda |1+| cdr do null error dtpr not and cond)
(includef lambda load)
(include nlambda car load)
(load-a-file (lambda . local) sstatus setq and eval close eq read do list infile prog1 quote status let terpr patom cond)
(fasl-a-file lambda sstatus eq setq and cond fasl prog1 quote status let)
(load lexpr load-a-file fasl-a-file probef concat memq status quote getchar and cadr >& > |1+| return car eq null exploden nreverse setq error stringp symbolp or not cond cdr cons |1-| <& < do let let* arg)
(last lambda cdr null do)
(hunk lexpr |1+| arg cdr *rplacx do *makhunk haulong |1-| return eq error >& > cond setq prog)
(locatefunction (lambda . local) cons ncons apply caddr cadr car putprop cddr terpr close read makereadtable do concat infile setq drain patom quote get null cond let)
(help nlambda cdr locatefunction cons ncons quote apply memq greaterp lessp numberp or eq concat stringp and print car setq atom not do terpr patom null cond)
(getl lambda cddr return car memq null cdr plist atom cond do)
(getcharn lambda substringn)
(getchar lambda substring concat)
(floatp lambda type quote equal)
(flatsize lexpr arg explode length)
(fixp lambda quote type equal or)
(filepos lexpr equal arg fseek onep bigp not cdr null and zerop cond)
(ffasl lexpr cfasl quote setq >& > cond arg)
(expt lambda go / |1-| oddp return setq prog error log exp floatp times expt quotient lessp bigp not cdr null and zerop equal cond)
(exploden lambda append quote ncons last rplacd null car exploden cons setq cdr do aexploden atom cond)
(explodec lambda append ncons last rplacd null car explodec quote cons setq cdr do aexplodec atom cond)
(explode lambda append ncons last rplacd null car explode quote cons setq cdr do aexplode atom cond)
(exl nlambda quote exvi)
(exec nlambda go cdr car concat list eval return null cond quote setq prog)
(exvi lambda load eval close infile errset quote concat car list setq null cond prog)
(ex nlambda quote exvi)
(evenp lambda bigp cdr null and fixnum-BitAndNot boole zerop not cond)
(delq lexpr go bigp |1-| zerop rplacd car cdr cons null atom and return greaterp not arg setq eq =& = error <& < cond prog)
(delete lexpr go bigp |1-| zerop rplacd car equal cdr cons null atom and return greaterp not arg setq eq =& = error <& < cond prog)
(defprop nlambda caddr cadr car putprop)
(cvttoucilisp lambda get setsyntax quote sstatus)
(cvttomaclisp lambda sstatus quote setsyntax)
(cvttointlisp lambda sstatus quote setsyntax)
(copysymbol lambda plist setplist cxr getd putd eval set boundp cond uconcat)
(copy lambda cdr car copy cons atom cond)
(comment nlambda quote)
(bigp lambda quote type equal)
(gcafter nlambda comment prtpagesused allocate errset atom and lessp fix error terpr patom greaterp caddr times quotient cadr difference max ptime car opval |1+| setq quote boundp return null cond prog)
(prtpagesused lambda caddr cdr * fix eq opval cadr greaterp car setq terpr difference times quotient max print null cons quote memq cond do patom)
(sys:int-serv lambda *break break drain quote patom)
(sys:fpeint-serv lambda error)
(unwind-protect macro append list cons quote gensym cddr cadr)
(signp macro subst list atom error quote eq cond setq caddr cadr)
(sassq macro cons list car quote eq not atom or cond cadddr caddr cadr)
(sassoc macro cons list car quote eq not atom or cond cadddr caddr cadr)
(desetq macro cddr liszt-internal-do mapcar append de-compose gensym list atom cadr setq nreverse quote cons car cond null do cdr)
(throw macro cadr caddr quote list)
(catch macro cadr caddr quote list)
(max lexpr |1-| setq cdr greaterp cond <& < arg do)
(make-equivalent macro cons quote list caddr cadr)
