(File |/usr/lib/lisp/auxfns0.l|)
(listarray lexpr return cpy1 eval cons arrayref lessp |1-| do memq getaux car arraydims quote apply eq error getd arrayp symbolp and cond cdr arg setq prog)
(fillarrayarray lambda |1+| arrayref replace greaterp do getlength min |1-| setq prog)
(fillarray lambda |1+| cdr replace arrayref set greaterp do getaux car memq getlength |1-| arrayp fillarrayarray return getd setq symbolp cond prog)
(arraydims lambda quote *break break arrayp getd getaux symbolp cond)
(small-segment lambda return remprop putdelta putlength fake putdata marray putprop greaterp * rplacd - rplaca segment maknum cons + boole lessp not and error null cond cdr car quote get desetq setq prog)
(storeintern lambda cons apply)
(store macro return go cons apply getdisc bcdp quote dtpr or getd and cddr cadr cdr car setq eq cond prog caddr cdadr caadr)
(arrac-nD lexpr value-eval set cpy1 replace memq arrayref car * null cddr do error + |1+| eq cond length setq cdr arg getaux let)
(arrac-twoD lexpr error set caddr * + arrayref value-eval eq cond cdr arg getaux let)
(arrac-oneD lexpr error set arg arrayref cdr value-eval eq cond)
(ev-arraycall lambda apply)
(arraycall macro append quote cons cdddr caddr cadr)
(*array lexpr return putd arrayref set bigp not zerop and or sizeof getd small-segment marray let null apply cons |1-| do eq quote memq cdr arg error - setq lessp cond prog)
(array macro cdddr append caddr cadr list quote cons)
(xcons lambda cons)
(vil nlambda quote exvi)
(vi nlambda quote exvi)
(substequal lambda cdr car substequal cons atom equal cond)
(substeq lambda cdr car substeq cons atom eq cond)
(subst lambda substequal substeq symbolp cond)
(sublishelp lambda cons and or not car sublishelp cdr list assoc setq atom cond let)
(sublis lambda car sublishelp cdr assoc setq atom cond let)
(exchange2 lambda car cdr rplaca cadr setq prog)
(sortcarhelp lambda sortcarhelp exchange2 caar caadr funcall cdr null cond)
(sortcar lambda |1+| sortcarhelp greaterp do length setq return null cond prog)
(mergelists lambda go car funcall cdr return rplacd null cond cons setq prog)
(splitlist lambda cons return sub1 rplacd setq bigp not and zerop cdr null or do prog)
(sortmerge lambda prog1 rplaca cadr funcall not eq null do cdr car sortmerge mergelists return quotient splitlist setq greaterp cond prog)
(sort lambda length sortmerge setq)
(sload lambda eval print eq read do return terpr quote patom infile setq cond prog)
(shell lambda ncons apply setq flatc lessp cond quote getenv)
(reverse lambda cdr car cons do null cond)
(prog1 lexpr cdr arg)
(princ lexpr return not do cadr princ patom cddr null car quote and dtpr cdr arg setq eq cond prog)
(plusp lambda greaterp)
(oddp lambda bigp cdr null and boole zerop not cond)
(nreverse lambda return go rplacd cdr setq prog null cond)
(nconc lexpr |1+| last cons bigp not and zerop rplacd do cdr arg null eq cond)
(min lexpr |1-| setq cond lessp cdr arg do)
(member lambda cdr return car equal cond null do)
(makhunk lambda quote apply |1+| *rplacx equal do *makhunk return minusp haulong |1-| error greaterp numberp cond setq prog)
(macroexpand lambda go apply eq nreverse macroexpand null cdr do mapcar cons memq getdisc bcdp getd setq let car return atom cond prog)
(length lambda |1+| cdr do null cond)
(includef lambda load)
(include nlambda car load)
(load-a-file (lambda . local) eval close eq read do list infile let)
(load lexpr load-a-file cadr fasl return probef concat car memq null status quote and getchar eq > flatc let error stringp symbolp or not cond cons |1-| setq lessp do cdr arg)
(last lambda cdr null do)
(hunk lexpr |1+| cdr arg *rplacx do *makhunk return minusp haulong |1-| error greaterp cond setq prog)
(locatefunction (lambda . local) ncons apply caddr concat cadr car putprop cddr terpr close read makereadtable do infile setq drain patom quote get null cond let)
(help nlambda cdr locatefunction ncons quote apply memq greaterp lessp numberp or eq concat stringp and print car setq atom not do terpr patom null cond)
(getl lambda cddr return car memq null cdr plist atom cond do)
(getcharn lambda substringn)
(getchar lambda substring concat)
(floatp lambda type quote equal)
(flatsize lexpr cdr arg explode length)
(fixp lambda quote type equal or)
(filepos lexpr equal arg fseek onep bigp not cdr null and zerop cond)
(ffasl lexpr cfasl quote setq greaterp cond cdr arg)
(expt lambda go / |1-| oddp return setq prog log exp floatp times expt quotient lessp bigp not cdr null and zerop equal cond)
(exploden lambda append quote ncons last rplacd null car exploden cons setq cdr do aexploden atom cond)
(explodec lambda append ncons last rplacd null car explodec quote cons setq cdr do aexplodec atom cond)
(explode lambda append ncons last rplacd null car explode quote cons setq cdr do aexplode atom cond)
(exl nlambda quote exvi)
(exec nlambda go cdr car concat list eval return null cond quote setq prog)
(exvi lambda load eval close infile errset quote concat car list setq null cond prog)
(ex nlambda quote exvi)
(evenp lambda bigp cdr null and boole zerop not cond)
(delq lexpr go bigp |1-| zerop rplacd car eq cons null atom and return greaterp not cdr arg setq = error < cond prog)
(delete lexpr go bigp |1-| zerop rplacd car equal cons null atom and return greaterp not cdr arg setq = error < cond prog)
(defprop nlambda caddr cadr car putprop)
(cvttoucilisp lambda get setsyntax status eq cond quote sstatus)
(cvttomaclisp lambda sstatus quote setsyntax)
(cvttointlisp lambda sstatus quote setsyntax)
(copysymbol lambda plist setplist getd putd eval set boundp cond uconcat)
(copy lambda cdr car copy cons atom cond)
(comment nlambda quote)
(bigp lambda quote type equal)
(assoc lambda cdr return caar equal error dtpr not car cond null do)
(append1 lambda list append)
(gcafter nlambda comment apply allocate errset atom lessp and fix error terpr patom greaterp caddr cadr times max quotient car opval |1+| setq quote boundp return null cond prog)
(prtpagesused nlambda cdr caddr * times quotient fix print eq opval cadr greaterp setq terpr null cons car memq cond do quote patom)
(INT lambda *break break drain quote patom)
(FPEINT lambda error)
(unwind-protect macro append list cons quote gensym cddr cadr)
(signphelpfcn lambda greaterp bigp not cdr null and zerop or minusp eq cond)
(signp macro subst list atom error quote eq cond setq caddr cadr)
(sassq macro cons list car quote eq not atom or cond cadddr caddr cadr)
(sassoc macro cons list car quote eq not atom or cond cadddr caddr cadr)
(listify macro cadr list quote cons)
(let* macro cdr append quote cons list setq car null reverse do cddr cadr)
(de-compose lambda cdr car de-compose nconc quote apply cons ncons atom null cond)
(let macro list mapcar nconc mapcan nreverse cdar cdr quote de-compose append gensym cons atom cond car null setq do mapc cddr cadr)
(desetq macro cddr mapcar append de-compose gensym list atom cadr setq nreverse quote cons car cond null do cdr)
(lambdacvt lambda caddar cddar caar cadar mapcar append nreverse return gensym |1+| cdr list caddr cddr ncons cons atom |1-| setq quote eq cond null car do prog)
(defun macro return lambdacvt or and append list atom cdr eq quote null gensym concat car cons memq dtpr cond cddr cadr setq prog)
(defmcrooption lambda cdr defmcrooption caddar append quote concatl cadar list cons caar setq atom cadr defmcrosrch car eq null cond)
(defmcrosrch lambda nreverse list do mapcar ncons setq cdr defmcrooption cddr cadr defmcrosrch car eq append quote concatl cons atom null cond)
(defmacro macro caar dtpr ncons cdddr eval cadddr cond append nreverse car cdr null do mapcar cons cadr list quote caddr defmcrosrch setq)
(throw macro cadr caddr quote list)
(catch macro cadr caddr quote list)
(memq lambda cdr return car eq cond null do)
(max lexpr |1-| setq greaterp cond lessp cdr arg do)
(concatl lambda quote apply)
(append lexpr setq |1-| do bigp not null and zerop cdr arg append2args eq cond)
(append2args (lambda . local) go rplacd cdr car cons setq quote list err atom return null cond prog)
(declare nlambda)
