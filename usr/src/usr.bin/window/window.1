.\" @(#)window.1	3.5 84/04/05
.TH WINDOW 1 local
.SH NAME
window \- multiple window shell
.SH SYNOPSIS
.B window
[
.B \-t
] [
.B \-f
] [
.B \-d
] [
.B -e escape-char
]
.SH DESCRIPTION
\fIWindow\fP provides a window oriented working environment
on ordinary CRT terminals.
.PP
Windows are rectangular partitions on the physical terminal screen
that are indistinguishable from real terminals to processes running in
them.  Their sizes are determined at creation
time.  They are framed as necessary to mark the boundaries between
windows.  Each window, like terminals, has a cursor and a set of
control functions.  Most intelligent terminal functions such as line and
character deletion and insertion are supported.  Display modes
such as underlining and reverse video are supported if the terminal
allows them.
.PP
Each window has a text buffer which can be larger than the window.
Different parts of the buffer can be made visible through scrolling.
.PP
Windows are labeled with the digits ``1'' through ``9'',
thus a maximum of nine windows can exist at the same time.
One window, the current window, is treated specially.
This window is indicated by displaying its labels in reverse video.
.PP
Windows can overlap.  Some can be completely obscured by others.
The current window is always on top of all others.
.PP
Windows need not be completely within the edges of the terminal screen.
Thus a large window (possibly larger than the physical screen)
can be placed to show only a portion of its full size.  This
feature can in some situations replace the ability to change
window sizes which is not supported.
.PP
With each newly created window, a shell program is spawned with its
process environment tailored to that window.  In particular,
a pseudo-terminal device (\fIpty (4)\fP) is allocated, and becomes
the standard input, output and diagnostic output of the shell.  Its
special characters and modes (see \fIstty (1)\fP) are copied from
the user's real terminal.  Also,
a \fItermcap (5)\fP entry for this window is created
and passed to the shell as \fIenviron (8)\fP
variable \fBTERMCAP\fP.  This \fItermcap\fP entry contains the window's
size and characteristics as well as information about
the real terminal, such as the existence of underline, reverse
video and other display modes, and the codes produced by the terminal's
keypad (if any).  The name of the shell program used is obtained from
the environment variable \fBSHELL\fP.
.PP
When \fIwindow\fP starts up, the file \fI.windowrc\fP in the
user's home directory is checked.  If it exists, then the
commands contained in it are executed (see \fIsource\fP command below).
If \fI.windowrc\fP does not exist, then two
equal sized windows are created by default.
.PP
The command line arguments are
.TP
.B -t
Turn on terse mode (see \fIterse\fP command below).
.TP
.B -f
Don't perform any startup action.
.TP
.B -d
Ignore \fI.windowrc\fP and create the two default
windows instead.
.TP
.B -e escape-char
Set the escape character to \fIescape-char\fP.
.PP
The \fIwindow\fP program has two functional modes:  command mode
and conversation mode.
In conversation mode, the terminal's
real cursor is placed at the cursor position of the current
window and all keyboard input is sent to the process in that
window.  Output from windows is displayed at all times,
even in command mode.
Typing \fIwindow\fP's escape character (normally ^P)
in conversation mode switches \fIwindow\fP into
command mode.  In command mode, the top line of the
terminal screen becomes the command prompt window.
.PP
There are two types of commands.  Short commands are
usually one or two key strokes.  Long commands are
in the command window (see the ``:'' command below),
or read from a file (see \fIsource\fP below).  They are parsed
much like conventional programming languages, with a syntax
similar to that of C.  Numeric and string expressions and variables
are supported, as well as
conditional statements (if . . .).  The grammar is described below.
.PP
The short commands.  Below, \fI[1-9]\fP represents one of the
keys ``1'' through ``9,'' used to select the correponding window
``1'' through ``9.''
.TP
.B [1-9]
Select window \fI[1-9]\fP as the current window
and return to conversation mode.
.TP
.B %[1-9]
Select window \fI[1-9]\fP but stay in command mode.
.TP
.B ?
List a short summary of commands.
.TP
.B ^L
Redraw the screen.
.TP
.B escape
Return to conversation mode.
.TP
.B ^P
Return to conversation mode and write ^P to the
current window.  Thus, typing two ^P's in conversation
mode sends one to the current window.  If the \fIwindow\fP
escape is changed to some other character, that
character takes the place of ^P here.
.TP
.B ^^
Select the previous current window and return to conversation
mode.  This is useful for toggling between two windows.
.TP
.B q
Exit \fIwindow\fP.  Confirmation is requested.
.TP
.B ^Z
Suspend \fIwindow\fP.
.TP
.B w
Create a new window.  You are prompted for the positions
of the upper left and lower right corners of the window.
The cursor is placed on the screen and the keys ``h'', ``j'',
``k'', and ``l''
move the cursor left, down, up, and right, respectively.
The keys ``H'', ``J'', ``K'', and ``L'' move the cursor to the respective
limits of the screen.  Typing a number before the movement keys
repeats the movement that number of times.
Return enters the cursor position
as the upper left corner of the window.  The lower right corner
is entered in the same manner.  During this process,
the position and size of the new window are indicated by a rectangular
box drawn on the screen.  Typing escape (or ^[) at any point
cancels this command.
.IP
This window becomes the current window,
and is given the first available label.  The default buffer size
is used (see \fIbuffer\fP command below).
.IP
Only fully visible windows can be created this way.
.TP
.B c[1-9]
Close window \fI[1-9]\fP.  The process in the window is sent
the hangup signal (see \fIkill (1)\fP).  \fICsh (1)\fP should
handle this signal correctly and cause no problems.
.TP
.B C
Close all windows.
.TP
.B m[1-9]
Move window \fI[1-9]\fP to another location.  A box in the shape
of the window is drawn on
the screen to indicate the new position of the window, and the same keys as
those for the ``w'' command are used to position the box.  The
window can be moved partially off-screen.
.TP
.B M[1-9]
Move window \fI[1-9]\fP to its previous position.
.TP
.B S
Show all windows.  Each window is brought to the top in sequence,
with the terminal cursor placed on its label.  Typing escape
at this point will select the displayed window as the current window.
Return will display the next one.  This command is sometimes confusing,
but useful when there are a large number of windows and some are completely
hidden by others.
.TP
.B L
List all windows with their labels and the states of their shell processes.
.TP
.B ^Y
Scroll the current window up by one line.
.TP
.B ^E
Scroll the current window down by one line.
.TP
.B ^U
Scroll the current window up by half the window size.
.TP
.B ^D
Scroll the current window down by half the window size.
.TP
.B ^B
Scroll the current window up by the full window size.
.TP
.B ^F
Scroll the current window down by the full window size.
.TP
.B h
Move the cursor of the current window left by one column.
.TP
.B j
Move the cursor of the current window down by one line.
.TP
.B k
Move the cursor of the current window up by one line.
.TP
.B l
Move the cursor of the current window right by one column.
.TP
.B v
List all variables.  All currently defined variables are listed
with their values.
.TP
.B :
Enter a line to be executed as long commands.  Normal line
editing characters (erase character, erase word, erase line) are
supported.
.PP
Long commands.  A long command is either a conditional statement
or a simple command.  The simple long command consists of a
command name followed by
a list of arguments, terminated with newline or ``;''.  A command can
be continued on the next line by ending the first line with ``\\''. The
arguments can be numeric or string expressions.  Window supports both numeric
and string values.  A string is any word beginning with a letter or
``_'', followed by letters, digits, or ``_''.  Alternately, strings
can be quoted in ``"'' to include non-alphanumeric characters.  Numeric
values are simple strings of digits.  Boolean
values are represented by a numeric value not equal to zero.  The supported operators in increasing
precedence are
.TP
.B "boolean_expr ? expr1 : expr2"
Returns \fIexpr1\fP
if \fIboolean_expr\fP is true, \fIexpr2\fP otherwise.
.TP
.B boolean_expr1 || boolean_expr2
Logical or.  Short circuit evaluation is supported.
.TP
.B boolean_expr1 && boolean_expr2
Logical and, with short circuit evaluation.
.TP
.B numeric_expr1 | numeric_expr2
Bitwise or.
.TP
.B numeric_expr1 ^ numeric_expr2
Bitwise exclusive-or.
.TP
.B numeric_expr1 & numeric_expr2
Bitwise and.
.TP
.B expr1 == expr2, expr1 != expr2
Comparison (equal and not-equal, respectively).  The boolean
result of the comparison is returned.  The arguments can be numeric
or strings.
.TP
.B expr1 < expr2, expr1 > expr2, expr1 <= expr2, expr1 >= expr2
Less than, greater than, less than or equal to, greater than or equal to.
.TP
.B numeric_expr1 << numeric_expr2, numeric_expr1 >> numeric_expr2,
\fINumeric_expr1\fP is bit shifted left (or right) by \fInumeric_expr2\fP
bits.
.TP
.B numeric_expr1 + numeric_expr2, numeric_expr1 - numeric_expr2
Addition, subtraction.
.TP
.B numeric_expr1 * numeric_expr2, numeric_expr1 / numeric_expr2, numeric_expr1 % numeric_expr2
Multiplication, division, modulo.
.TP
.B - numeric_expr, + numeric_expr, ~ numeric_expr, ! boolean_expr
Unary minus, unary plus, bitwise complement, logical complement.
.PP
The long commands:
.TP
.B escape C
Set the escape character to \fIC\fP.
.TP
.B terse [off]
Turn on (or off) terse mode.  In terse mode, the command window
stays hidden even in command mode, and errors are reported by
sounding the terminal's bell.
.TP
.B window row col nrow ncol [nline]
Open a window with upper left corner at \fIrow\fP, \fIcol\fP
and size \fInrow\fP, \fIncol\fP.  If \fInline\fP is specified,
then that many lines is allocated for the text buffer.  Otherwise,
the default buffer size is used.  Using a \fB``*''\fP in place of
\fIrow\fP, \fIcol\fP, \fInrow\fP, or \fIncol\fP gives, respectively,
the up, left, down, or right extremes of the screen.
.TP
.B buffer nline
Set the default buffer size to \fInline\fP.  Initially, it is
48 lines.  Using a very large buffer can slow the program down
considerably.
.TP
.B label [1-9] string
Label window \fI[1-9]\fP with \fIstring\fP.  This is in addition
to the numeric label that is always displayed.
.TP
.B %[1-9]
Make window \fI[1-9]\fP the current window.
.TP
.B write [1-9] string
Write \fIstring\fP to window \fI[1-9]\fP.
.TP
.B close [1-9] ...
Close window \fI[1-9]\fP.  More than one window can be specified.
If no window is given, then all windows are closed.
.TP
.B source file
Read and execute the long commands in \fIfile\fP.  Recursive
\fIsource\fP is not allowed.
.SH FILES
.ta 15
~/.windowrc	startup command file.
.br
/dev/ptyp?	pseudo-terminal devices.
.SH DIAGNOSTICS
Should be self explanatory.
.SH BUGS
When a window is scrolled or the cursor moved, output from
the process in the window will be displayed at the new cursor
position.  This is consistent with real terminals but
not always desirable.
