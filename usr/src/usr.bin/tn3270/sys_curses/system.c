#include <sys/wait.h>

#include <stdio.h>

#include "../general/general.h"
#include "../api/api.h"

#include "../general/globals.h"


static int shell_pid = 0;

static int
child_died()
{
    union wait *status;

    while ((pid = wait3(status, WNOHANG, 0)) > 0) {
	if (pid == shell_pid) {
	    shell_active = 0;
	}
    }
    signal(SIGCHLD, child_died);
}

/*
 * shell_continue() actually runs the command, and looks for API
 * requests coming back in.
 *
 * We are called from the main loop in telnet.c.
 */

int
shell_continue()
{
    return shell_active;
}


/*
 * Called from telnet.c to fork a lower command.com.  We
 * use the spint... routines so that we can pick up
 * interrupts generated by application programs.
 */


int
shell(argc,argv)
int	argc;
char	*argv[];
{
    if ((shell_pid = fork()) {
	shell_active = 1;		/* We are running down below */
	child_killed();			/* Start up signal handler */
    } else {				/* New process */
	register int i;

	for (i = 3; i < 30; i++) {
	    (void) close(i);
	}
	if (argc == 1) {		/* Just get a shell */
	    char *cmdname;

	    cmdname = getenv("SHELL");
	    execlp(cmdname, cmdname, 0);
	    perror("Exec'ing new shell...\n");
	    exit(1);
	} else {
	    execvp(argv[1], &argv[1]);
	    perror("Exec'ing command.\n");
	    exit(1);
	}
	/*NOTREACHED*/
    }
    return 1;			/* Go back to main loop */
}
