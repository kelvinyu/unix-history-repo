.TH PUP 4F "1 April 1982"
.UC
.SH NAME
pup \- Xerox PUP-I protocol family
.SH SYNOPSIS
.B #include <sys/types.h>
.br
.B #include <netpup/pup.h>
.SH DESCRIPTION
.de _d
.if t .ta .6i 2.1i 2.6i
.\" 2.94 went to 2.6, 3.64 to 3.30
.if n .ta .84i 2.6i 3.30i
..
.de _f
.if t .ta .5i 1.25i 2.5i
.\" 3.5i went to 3.8i
.if n .ta .7i 1.75i 3.8i
..
The PUP-I protocol family is a collection of protocols
layered atop the PUP Level-0 packet format, and
utilizing the PUP Internet address format.
The PUP family is currently supported only by a raw interface.
.SH ADDRESSING
PUP addresses are composed of network, host, and port
portions.
The include file
.RI < netpup/pup.h >
defines this address as,
.sp 1
.nf
._f
struct pupport {
	u_char	pp_net;
	u_char	pp_host;
	u_long	pp_socket;
};
.sp 1
.fi
Sockets bound to the PUP protocol family utilize
the following addressing structure,
.sp 1
.nf
._f
struct sockaddr_pup {
	short	spup_family;
	short	spup_zero1;
	struct	pupport spup_addr;
	char	spup_zero2[4];
};
.fi
.SH HEADERS
The current PUP support provides only raw access to the
Ethernet.  Packets sent and received through this interface
have the following packet header present,
.sp 1
.nf
._f
struct pup_header {
	u_short	pup_length;
	u_char	pup_tcontrol;		/* transport control */
	u_char	pup_type;		/* protocol type */
	u_long	pup_id;			/* used by protocols */
	struct	pupport pup_dport, pup_sport;
};
.fi
.PP
As mentioned above, the length and source \*(lqport\*(rq are automatically
filled in by the raw interface software.  The
.I tcontrol
field is restricted to be 0 or 1; with 1 indicating packet tracing
should be performed.
.SH SEE ALSO
intro(4N), pup(4P), en(4V)
.SH BUGS
The only interface which currently supports use of pup's 
is the Xerox 3 Mb/s
.IR en (4V)
interface.
.PP
With the release of the second generation, PUP-II, protocols
it is not clear what future PUP-I has.  Consequently, there
has been little motivation to provide extensive kernel support.
.PP
Routing support should be provided; currently the destination
host and network are used in encapsulating the packet in the
interface driver.
