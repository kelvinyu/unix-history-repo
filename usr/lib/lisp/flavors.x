(File flavors.l)
(flavor-components-defined-p lambda format flavor-includes cdr return car flavor-components-defined-p flavor-depends-on do and vref flavor-depends-on-all null not or get-flavor setq cond)
(compile-flavor-methods-2 lambda compose-method-combination flavor-method-hash-table compose-flavor-combination flavor-depends-on-all or flavor-components-defined-p vref flavor-plist putprop ferror quote get setq not cond if check-arg)
(compile-flavor-methods-1 lambda compose-method-combination compose-flavor-combination vref flavor-depends-on-all or flavor-redefinition-for-compilation compilation-define-flavor get eq and get-flavor setq quote flavor-components-defined-p let just-compiling cond if)
(compile-flavor-methods macro nreverse mapcar rplacd ncons get and nconc car setq cond null liszt-internal-do mapcan cons quote list cdr)
(compile-at-appropriate-time lambda cdr lambdacvt method-function-name putd)
(set-in-instance lambda set-in-fclosure ferror quote function fclosure-function eq fclosurep and instancep not cond if check-arg)
(g01775::symeval-in-instance lambda caddr cadr quote list)
(symeval-in-instance lambda symeval-in-fclosure ferror quote function fclosure-function eq fclosurep and instancep not cond if check-arg)
(get-flavor-handler-for lambda gethash compose-method-combination flavor-method-hash-table compose-flavor-combination vref flavor-depends-on-all or ferror quote get setq not cond if check-arg)
(get-handler-for lambda int:fclosure-stack-stuff function fclosure-function eq fclosurep and instancep vref flavor-name :typep get-flavor-handler-for quote get symbolp cond setq)
(macrocall macro Internal-bcdcall getdisc bcdp setq cxr getd symbolp quote cons funcall eq listp and if ferror car method-function-name cond let cdr)
(put-wrapper-into-combined-method lambda quote list car eq dtpr and not ferror method-function-name cxr getd cond let)
(in-line-lambda:492924674 lambda return eq cond cdr car setq go null and prog vref flavor-depends-on-all cadr loop)
(get-specially-combined-methods lambda quote function rplacd last append return caar eq do assq cond cdr car setq go null and prog cdddr loop sort)
(make-combined-method lambda cons compile-at-appropriate-time flavor-notice-method Internal-bcdcall getdisc bcdp cxr getd symbolp and cdr return caar eq cond caddr assq cadr funcall null do dolist get-specially-combined-methods car vref flavor-name quote list setq)
(print-combined-method-derivation lambda caddr cadr or cond if format cdr car setq go null and prog cdddr loop)
(have-combined-method lambda print-combined-method-derivation flavor-name format progn meth-plist get equal meth-function-spec nthcdr nth meth-definition meth-definedp meth-lookup cdr return caar cond flavor-method-table assq eq not neq and get-flavor let null vref flavor-depends-on-all do dolist or car setq quote function cdddr sortcar cddr rplacd setf)
(specially-combined-methods-present lambda return caar eq cond do assq cdr car setq go null and prog cdddr loop)
(get-certain-methods lambda reverse caddr caseq selectq not and quote cadr ferror memq or return caar assq cdr eq cond car setq null cdddr do dolist)
(g01542:::pass-on lambda list if quote make-combined-method have-combined-method or cdr cons setf push eq cond listp and car nreverse setq null do cdaddr caaddr get-certain-methods let)
(simple-method-combination lambda nreverse method-call setq liszt-internal-do mapcar cadr cons make-combined-method have-combined-method car cdr null not and or specially-combined-methods-present get-certain-methods let)
(g01517:::inverse-list lambda cdr and car list setq setf push nreverse null get-certain-methods do quote cons make-combined-method have-combined-method or)
(g01505:::list lambda nreverse cdr car method-call setq null get-certain-methods liszt-internal-do mapcar quote cons make-combined-method have-combined-method or)
(g01490:::daemon-with-and lambda daemon-combination make-combined-method have-combined-method not or list rplacd setf cddr and cdr return caar eq cond null cdddr do assq specially-combined-methods-present quote get-certain-methods car let)
(g01475:::daemon-with-or lambda daemon-combination make-combined-method have-combined-method not or list rplacd setf cddr and cdr return caar eq cond null cdddr do assq specially-combined-methods-present quote get-certain-methods car let)
(g01455:::daemon-with-override lambda daemon-combination nreverse method-call setq liszt-internal-do mapcar append cons make-combined-method have-combined-method not or list rplacd setf cddr and cdr return caar eq cond null cdddr do assq specially-combined-methods-present quote get-certain-methods car let)
(method-call lambda method-function-name list quote cons)
(daemon-combination lambda nreverse cdr car null liszt-internal-do mapcar append cons quote list setq cond if method-call and let)
(g01397:::daemon lambda daemon-combination make-combined-method have-combined-method not or list rplacd setf cddr and cdr return caar eq cond null cdddr do assq specially-combined-methods-present quote get-certain-methods car let)
(compose-flavor-initializations lambda rplacd memq go prog flavor-allowed-init-keywords loop function sortcar atom not flavor-local-instance-variables cddr putprop memq-alternated cons push return caar eq assq cond if cadr let* nthcdr rplaca and cdr find-position-in-list flavor-initable-instance-variables quote flavor-plist get vset setf flavor-default-handler or get-flavor let car null flavor-depends-on-all do dolist vref flavor-all-instance-variables length make-list setq list)
(corresponding-keyword lambda concat intern getcharn eq =& = cond if)
(compose-automatic-methods lambda nreverse format intern flavor-settable-instance-variables cdr cons setf push flavor-name quote list let corresponding-keyword car setq null vref flavor-gettable-instance-variables do dolist)
(in-line-lambda:492924673 lambda car cons setq setf push declare)
(flavor-method-alist lambda function maphash and vref flavor-method-hash-table let quote get setq symbolp cond if)
(flavor-unclaimed-message lambda quote ferror print format declare)
(verify-required-flavors-methods-and-ivars lambda flavor-all-instance-variables first cons setf push progn memq cdr return caar eq cond assq setq dolist quote car get flavor-plist let length flavor-name ferror or and null vref flavor-depends-on-all do)
(compose-method-combination lambda verify-required-flavors-methods-and-ivars puthash length times fix make-hash-table vset >& > method-function-name swaphash progn multiple-value multiple-value-bind flavor-method-hash-table remhash Internal-bcdcall getdisc bcdp cxr getd symbolp funcall delq nreverse rplaca ferror neq cadr memq list cddr rplacd let list* cons setf push meth-definedp caddr third nthcdr nth meth-function-spec meth-method-type cdddr cdr return caar assq eq or flavor-method-table dolist append copylist nconc quote get and flavor-plist car get-flavor setq null vref flavor-depends-on-all do compose-flavor-initializations not cond if)
(in-line-lambda:492924672 lambda cons setf push memq or vref flavor-name setq)
(compose-flavor-inclusion-1 lambda prog2 values return list not cond go and prog loop nreverse nconc cdr rplacd rplaca cons setf push memq or setq car get-flavor vref flavor-includes dolist null do quote function map-over-component-flavors let)
(compose-flavor-inclusion lambda nreverse setf push return quote get-flavor vref flavor-plist get go and prog loop or cons rplacd rplaca memq dolist car null do >& > not cdr <& < cond if compose-flavor-inclusion-1 setq progn multiple-value let multiple-value-bind)
(compose-flavor-combination lambda putprop delq nreverse ferror return flavor-all-instance-variables compose-flavor-combination flavor-depends-on-all cond flavor-plist get union cdr atom flavor-local-instance-variables car do dolist push flavor-depended-on-by memq eq neq null not and quote get-flavor let vset setf or vref flavor-name compose-flavor-inclusion append copylist setq cons)
(flavor-depended-on-by-all lambda cdr cons flavor-depended-on-by-all quote get not memq or car setq null vref flavor-depended-on-by do dolist)
(recompile-flavor lambda cdr recompile-flavor car null flavor-depended-on-by-all do dolist let compose-method-combination compose-flavor-combination flavor-depends-on-all or vref flavor-method-hash-table ferror quote get not cond if check-arg setq)
(map-over-component-flavors lambda flavor-includes function car vref flavor-depends-on do dolist *throw lexpr-funcall bigp cdr null and fixnum-BitAndNot boole zerop bit-test ferror setq not if check-arg get-flavor or cond quote *catch prog)
(eliminate-duplicates lambda cdr cons setf push memq or car setq null do dolist)
(flavor-local-init-keywords lambda flavor-init-keywords vref flavor-initable-instance-variables append)
(in-line-lambda:492924671 lambda nreverse cdr listp cond if car cons null flavor-local-init-keywords liszt-internal-do mapcar nconc setq declare)
(flavor-allowed-init-keywords lambda eliminate-duplicates sort quote function map-over-component-flavors declare let)
(in-line-lambda:492924670 lambda flavor-name flavor-init-keywords memq cdr car return caar eq cond null vref flavor-initable-instance-variables do assq or and)
(flavor-allows-init-keyword-p lambda quote function map-over-component-flavors)
(flavor-default-init-plist lambda cddr return eq and cadr eval putprop cdr flavor-plist car null do dolist compose-flavor-combination vref flavor-depends-on-all or ferror quote get not cond if check-arg cons ncons setq)
(fast-eval lambda eval cadr car eq listp and cdr symeval symbolp memq stringp numberp or cond)
(memq-alternated lambda cddr return car eq cond if null do)
(instantiate-flavor lambda prog2 values send-internal send get-handler-for flavor-init-keywords return eq flavor-initable-instance-variables assq flavor-default-init-plist putprop memq-alternated flavor-remaining-default-plist cddr push cadr remove-colon memq null do flavor-remaining-init-keywords flavor-all-initable-instance-variables let set-in-fclosure |1+| cdr setf car pop cadar fast-eval int:fclosure-stack-stuff caar equal = go greaterp and prog flavor-plist flavor-instance-variable-initializations length loop internal-unbind-vars function fclosure progn prog1 list append cons internal-bind-vars progv flavor-all-instance-variables compose-method-combination flavor-method-hash-table compose-flavor-combination vref flavor-depends-on-all or ferror quote get setq not cond if check-arg)
(flavor-dispatch lambda flavor-unclaimed-message lexpr-funcall null not cond if flavor-default-handler vref flavor-method-hash-table gethash or setq declare)
(make-instance lambda quote cons instantiate-flavor)
(undefmethod macro cons quote list cadr)
(flavor-method-exists lambda meth-definedp cdddr meth-lookup let cdr car return caar eq cond null vref flavor-method-table do assq setq and)
(flavor-method-entry lambda cddr rplacd nullify-method-definition list list* cons vset setf push cdddr meth-lookup return caar vref flavor-method-table do assq vsetprop vector make-flavor putprop and quote get get-flavor let* ferror symbolp length cdr >& > car first eq not neq or setq null cond if cadddr fourth caddr third cadr second let)
(method-function-name lambda remove-colon format intern setq cdddr null cond if cadddr fourth caddr third cadr second let)
(flavor-notice-method lambda last cadr second recompile-flavor rplaca setf method-function-name cdr nthcdr car nth meth-definition eq not cond flavor-method-entry let)
(defwrapper macro append cons equal symbolp and cond if method-function-name setq quote list let cdddr cdaddr caaddr cadadr caadr)
(destructuring-bind macro list quote cons cdddr caddr cadr)
(remove-colon lambda substring concat getcharn eq =& = cond if)
(defmethod macro ferror get-flavor vref flavor-all-instance-variables append get null not symbolp and cond list method-function-name setq quote cons car let cdddr caddr cadr)
(describe-flavor lambda print cddr flavor-plist flavor-init-keywords nreverse cons liszt-internal-do mapcar flavor-initable-instance-variables flavor-settable-instance-variables flavor-gettable-instance-variables terpri cadr princ cdr caddr third nthcdr nth meth-function-spec meth-method-type cdddr subset car do dolist flavor-method-table null flavor-all-instance-variables flavor-method-hash-table flavor-depends-on-all flavor-depended-on-by flavor-includes and vref flavor-depends-on format ferror quote :typep not check-arg get-flavor symbolp cond if setq)
(perform-flavor-method-only-redefinition lambda cdr compose-method-combination flavor-method-hash-table compose-flavor-combination vref flavor-depends-on-all cond if car setq null list quote get flavor-depended-on-by-all reverse do dolist let)
(perform-flavor-redefinition lambda cdr perform-flavor-redefinition car null flavor-depended-on-by do dolist format putprop flavor-plist append copylist vset setf copy-method-table copy vsetprop vector let make-flavor vref flavor-method-hash-table cond quote get setq)
(compilation-define-flavor lambda putprop ncons cons setq setf push cdr car return caar eq cond null quote do assq let)
(copy-method-table lambda vset nullify-method-definition meth-definition meth-definedp first list cdr cdddar delq cddar rplacd caddr third nthcdr nth meth-function-spec meth-method-type eq and cdddr cond if car rplaca setf null do vref flavor-method-table append copylist let)
(flavor-redefinition-for-compilation lambda vset setf copy-method-table copy setq quote vsetprop vref flavor-name vector make-flavor let)
(in-line-lambda:492924669 lambda vref flavor-local-instance-variables)
(flavor-relevant-components lambda vref flavor-name compose-flavor-inclusion quote function del-if-not vset setf)
(validate-instance-variables-spec lambda nreverse format cond cdr cons setf push memq or car setq null do dolist)
(defflavor1 lambda perform-flavor-method-only-redefinition delq flavor-depended-on-by list* assq cadr rplaca cddr flavor-method-table return rplacd corresponding-keyword go prog loop vset vsetprop vector make-flavor let perform-flavor-redefinition flavor-relevant-components flavor-init-keywords flavor-initable-instance-variables flavor-local-instance-variables flavor-includes flavor-depends-on equal and validate-instance-variables-spec eq caseq selectq cdar caar vref flavor-plist putprop get ferror symbolp or do dolist nreverse cdr atom if car null liszt-internal-do mapcar cons setq setf push memq not cond quote list)
(meth-definedp lambda cdr nthcdr car nth meth-definition null not)
(nullify-method-definition lambda cdr nthcdr rplaca setf)
(meth-lookup lambda return caddr third nthcdr nth meth-function-spec cdddr meth-method-type eq cond cdr car setq go null and prog loop)
(meth-method-type macro quote list cadr)
(alter-meth macro defstruct-expand-alter-macro)
(meth-function-spec macro defstruct-expand-ref-macro)
(meth-definition macro defstruct-expand-ref-macro)
(meth-plist macro defstruct-expand-ref-macro)
(g00161::flavor lambda ferror describe-flavor maknum vref flavor-name format car patom progn si:printing-random-object quote eq cond caseq selectq)
(flavor-all-initable-instance-variables::cmacro:g00156 macro quote cons list sublis cadr)
(flavor-all-initable-instance-variables lambda quote vref flavor-plist get)
(flavor-remaining-init-keywords::cmacro:g00146 macro quote cons list sublis cadr)
(flavor-remaining-init-keywords lambda quote vref flavor-plist get)
(flavor-remaining-default-plist::cmacro:g00136 macro quote cons list sublis cadr)
(flavor-remaining-default-plist lambda quote vref flavor-plist get)
(flavor-instance-variable-initializations::cmacro:g00126 macro quote cons list sublis cadr)
(flavor-instance-variable-initializations lambda quote vref flavor-plist get)
(flavor-additional-instance-variables::cmacro:g00116 macro quote cons list sublis cadr)
(flavor-additional-instance-variables lambda quote vref flavor-plist get)
(instance-typep lambda flavor-depends-on-all memq not quote symeval-in-fclosure instance-flavor vref flavor-name null cond if)
(get-flavor lambda ferror not if check-arg get setq symbolp quote :typep cond)
(instance-function::cmacro:g00083 macro quote cons list sublis cadr)
(instance-function lambda fclosure-function)
(instance-flavor::cmacro:g00074 macro quote cons list sublis cadr)
(instance-flavor lambda quote symeval-in-fclosure)
(instance-variable-boundp macro quote list cadr)
(defun-method macro get-flavor vref flavor-all-instance-variables append list quote cons cddddr cadddr caddr cadr)
(defflavor macro find-position-in-list + memq intern concat assq or nreverse cdr atom setq liszt-internal-do mapcar cdar return caar eq car listp and do get compose-automatic-methods list quote cons get-flavor compose-flavor-combination cxr getd null not cond if defflavor1 append copylist let cddddr cadddr caddr cadr)
