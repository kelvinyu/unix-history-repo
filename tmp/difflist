diff -r src/sys/stand/gets.c ../src/sys/stand/gets.c
17c17
<  *	@(#)gets.c	7.4 (Berkeley) 9/12/88
---
>  *	@(#)gets.c	7.3 (Berkeley) 6/29/88
33d32
< 		case '\177':
41a41
> 		case '\177':
diff -r src/sys/stand/ls.c ../src/sys/stand/ls.c
17c17
<  *	@(#)ls.c	7.5 (Berkeley) 3/21/89
---
>  *	@(#)ls.c	7.4 (Berkeley) 6/29/88
25d24
< #include "ttychars.h"
32,45c31,37
< 	for (;;) {
< 		if ((fd = getfile("ls", 0)) == -1)
< 			exit();
< 		ip = &iob[fd - 3].i_ino;
< 		if ((ip->i_mode & IFMT) != IFDIR) {
< 			printf("ls: not a directory\n");
< 			continue;
< 		}
< 		if (ip->i_size == 0) {
< 			printf("ls: zero length directory\n");
< 			continue;
< 		}
< 		ls(fd);
< 	}
---
> 	fd = getfile("ls", 0);
> 	ip = &iob[fd - 3].i_ino;
> 	if ((ip->i_mode & IFMT) != IFDIR)
> 		_stop("ls: not a directory");
> 	if (ip->i_size == 0)
> 		_stop("ls: zero length directory");
> 	ls(fd);
48,63d39
< getfile(prompt, mode)
< 	char *prompt;
< 	int mode;
< {
< 	int fd;
< 	char buf[100];
< 
< 	do {
< 		printf("%s: ", prompt);
< 		gets(buf);
< 		if (buf[0] == CTRL('d') && buf[1] == 0)
< 			return (-1);
< 	} while ((fd = open(buf, mode)) <= 0);
< 	return(fd);
< }
< 
73c49
< 	printf("\ninode\tname\n");
---
> 	printf("\nname->inode\n");
80,85c56,61
< 			if (((DP *)dp)->d_namlen > MAXNAMLEN+1) {
< 				printf("Corrupt file name length!  Run fsck soon!\n");
< 				return;
< 			}
< 			printf("%d\t%s\n", ((DP *)dp)->d_ino,
< 			    ((DP *)dp)->d_name);
---
> 			if (((DP *)dp)->d_reclen > DIRSIZ(((DP *)dp)))
> 				continue;
> 			if (((DP *)dp)->d_namlen > MAXNAMLEN+1)
> 				_stop("Corrupt file name length!  Run fsck soon!\n");
> 			printf("%s->%d\n", ((DP *)dp)->d_name,
> 			    ((DP *)dp)->d_ino);
diff -r src/sys/stand/saio.h ../src/sys/stand/saio.h
2,3c2,4
<  * Copyright (c) 1982, 1988 The Regents of the University of California.
<  * All rights reserved.
---
>  * Copyright (c) 1982, 1988 Regents of the University of California.
>  * All rights reserved.  The Berkeley software License Agreement
>  * specifies the terms and conditions for redistribution.
5,17c6
<  * Redistribution and use in source and binary forms are permitted
<  * provided that the above copyright notice and this paragraph are
<  * duplicated in all such forms and that any documentation,
<  * advertising materials, and other materials related to such
<  * distribution and use acknowledge that the software was developed
<  * by the University of California, Berkeley.  The name of the
<  * University may not be used to endorse or promote products derived
<  * from this software without specific prior written permission.
<  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
<  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
<  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
<  *
<  *	%W% (Berkeley) %G%
---
>  *	@(#)saio.h	7.3 (Berkeley) 3/2/88
23c12
< #define	UNIX	"hd(6,0,0) /vmunix"
---
> #define	UNIX	"/vmunix"
32c21
< 	int	i_adapt;	/* adapter or bus */
---
> 	int	i_adapt;	/* adapter */
52d40
< 
54d41
< #define	i_bus	i_adapt
61,68c48,55
< #define	F_READ		0x0001	/* file opened for reading */
< #define	F_WRITE		0x0002	/* file opened for writing */
< #define	F_ALLOC		0x0004	/* buffer allocated */
< #define	F_FILE		0x0008	/* file instead of device */
< #define	F_NBSF		0x0010	/* no bad sector forwarding */
< #define	F_ECCLM		0x0020	/* limit # of bits in ecc correction */
< #define	F_SSI		0x0040	/* set skip sector inhibit */
< #define	F_SEVRE		0x0080	/* Severe burnin (no retries, no ECC) */
---
> #define	F_READ		0x1	/* file opened for reading */
> #define	F_WRITE		0x2	/* file opened for writing */
> #define	F_ALLOC		0x4	/* buffer allocated */
> #define	F_FILE		0x8	/* file instead of device */
> #define	F_NBSF		0x10	/* no bad sector forwarding */
> #define	F_ECCLM		0x20	/* limit # of bits in ecc correction */
> #define	F_SSI		0x40	/* set skip sector inhibit */
> #define	F_SEVRE		0x80	/* Severe burnin (no retries, no ECC) */
78a66,68
> /*
>  * Request codes. Must be the same as F_XXX above
>  */
diff -r src/sys/tahoe/autoconf.c ../src/sys/tahoe/autoconf.c
305,306c305
< 		if (VBIOMAPPED(addr)) 
< 			ui->ui_addr = (caddr_t)reg;
---
> 		ui->ui_addr = (caddr_t)reg;
Only in src/sys/tahoe: autoconf.c.nbsd
diff -r src/sys/tahoe/conf.c ../src/sys/tahoe/conf.c
17c17
<  *	@(#)conf.c	7.4 (Berkeley) 5/1/89
---
>  *	@(#)conf.c	7.3 (Berkeley) 6/29/88
42,54d41
< #include "hd.h"
< #if NHD > 0
< int	hdopen(),hdclose(),hdstrategy(),hdioctl();
< int	hddump(),hdsize();
< #else
< #define	hdopen		nodev
< #define	hdclose		nodev
< #define	hdstrategy	nodev
< #define	hdioctl		nodev
< #define	hddump		nodev
< #define	hdsize		0
< #endif
< 
74,75c61,62
< 	{ hdopen,	hdclose,	hdstrategy,	hdioctl,	/*2*/
< 	  hddump,	hdsize,		0 },
---
> 	{ nodev,	nulldev,	nodev,		nodev,		/*2*/
> 	  nodev,	0,		0 },
212,214c199,201
< 	hdopen,		hdclose,	rawread,	rawwrite,	/*6*/
< 	hdioctl,	nodev,		nulldev,	NULL,
< 	seltrue,	nodev,		hdstrategy,
---
> 	nodev,		nulldev,	nodev,		nodev,		/*6*/
> 	nodev,		nodev,		nulldev,	NULL,
> 	seltrue,	nodev,		NULL,
diff -r src/sys/tahoe/genassym.c ../src/sys/tahoe/genassym.c
25c25
< static char sccsid[] = "@(#)genassym.c	7.3 (Berkeley) 9/24/88";
---
> static char sccsid[] = "@(#)genassym.c	7.2 (Berkeley) 6/29/88";
81d80
< 	printf("#define\tMCLBYTES %d\n", MCLBYTES);
diff -r src/sys/tahoe/locore.s ../src/sys/tahoe/locore.s
6c6
<  *	@(#)locore.s	7.6 (Berkeley) 5/1/89
---
>  *	@(#)locore.s	7.2 (Berkeley) 7/6/88
606c606
< 	SYSMAP(Mbmap	,mbutl		,NMBCLUSTERS*MCLBYTES/NBPG+CLSIZE )
---
> 	SYSMAP(Mbmap	,mbutl		,NMBCLUSTERS*CLSIZE+CLSIZE )
615,618d614
< #include "hd.h"
< #if NHD > 0
< 				ADDMAP(	NHDC*(MAXPHYS/NBPG+CLSIZE) )
< #endif
620d615
< #if NDK > 0
622d616
< #endif
624d617
< #if NYC > 0
626d618
< #endif
635d626
< #if NACE > 0
637,644d627
< #endif
< #if NHD > 0
< 				ADDMAP( NHDC )
< #endif
< #include "vx.h"
< #if NVX > 0
< 				ADDMAP( NVX * 16384/NBPG )
< #endif
648,651d630
< #if NHD > 0
< 				ADDMAP(	NHDC*(MAXPHYS/NBPG+CLSIZE) )
< #endif
< #if NDK > 0
653,654d631
< #endif
< #if NYC > 0
656d632
< #endif
854,856c830,831
< 	/* try /sbin/init */
< 	pushab	b`argv1-l0(pc)
< l0:	pushab	b`init1-l1(pc)
---
> 	pushab	b`argv-l0(pc)
> l0:	pushab	b`init-l1(pc)
860,866d834
< 	/* try /etc/init */
< 	pushab	b`argv2-l2(pc)
< l2:	pushab	b`init2-l3(pc)
< l3:	pushl	$2
< 	movab	(sp),fp
< 	kcall	$SYS_execv
< 	/* give up */
868,869d835
< 	pushl	$1
< 	movab	(sp),fp
872,873c838
< init1:	.asciz	"/sbin/init"
< init2:	.asciz	"/etc/init"
---
> init:	.asciz	"/etc/init"
877c842
< argv1:	.long	init1+6-_icode
---
> argv:	.long	init+5-_icode
880,882d844
< argv2:	.long	init2+5-_icode
< 	.long	_initflags-_icode
< 	.long	0
907,928d868
< 2:	movl	r2,_scb+SCB_BUSERR
< 	mtpr	r1,$IPL
< 	ret
< 
< /*
<  * wbadaddr(addr, len, value)
<  *	see if write of value to addr with a len type instruction causes
<  *	a machine check
<  *	len is length of access (1=byte, 2=short, 4=long)
<  *	r0 = 0 means good(exists); r0 =1 means does not exist.
<  */
< ENTRY(wbadaddr, R3|R4)
< 	mfpr	$IPL,r1
< 	mtpr	$HIGH,$IPL
< 	movl	_scb+SCB_BUSERR,r2
< 	movl	4(fp),r3
< 	movl	8(fp),r4
< 	movab	9f,_scb+SCB_BUSERR
< 	bbc	$0,r4,1f; movb	15(fp), (r3)
< 1:	bbc	$1,r4,1f; movw	14(fp), (r3)
< 1:	bbc	$2,r4,1f; movl	12(fp), (r3)
< 1:	clrl	r0			# made it w/o machine checks
Only in src/sys/tahoe: locore.s.okeeffe
diff -r src/sys/tahoeif/if_ace.c ../src/sys/tahoeif/if_ace.c
5,7d4
<  * This code is derived from software contributed to Berkeley by
<  * Computer Consoles Inc.
<  *
20c17
<  *	@(#)if_ace.c	7.5 (Berkeley) 4/25/89
---
>  *	@(#)if_ace.c	7.2 (Berkeley) 6/29/88
31d27
< #include "malloc.h"
58,59c54,55
< #include "machine/cpu.h"
< #include "machine/pte.h"
---
> #include "../machine/cpu.h"
> #include "../machine/pte.h"
65c61
< int	aceprobe(), aceattach(), acerint(), acecint(), acestart();
---
> int	aceprobe(), aceattach(), acerint(), acecint();
175,176c171
< 	ifp->if_output = ether_output;
< 	ifp->if_start = acestart;
---
> 	ifp->if_output = aceoutput;
179c174
< 	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX;
---
> 	ifp->if_flags = IFF_BROADCAST;
206a202
> 	register struct ifnet *ifp = &is->is_if;
210c206
< 	if (is->is_if.if_addrlist == (struct ifaddr *)0)
---
> 	if (ifp->if_addrlist == (struct ifaddr *)0)
212c208
< 	if ((is->is_if.if_flags & IFF_RUNNING) == 0) {
---
> 	if ((ifp->if_flags & IFF_RUNNING) == 0) {
240c236
< 		acestart(&is->is_if);
---
> 		acestart(unit);
248,249c244,245
< acestart(ifp)
< 	register struct ifnet *ifp;
---
> acestart(unit)
> 	int unit;
253a250
> 	register struct ace_softc *is = &ace_softc[unit];
256d252
< #define	is ((struct ace_softc *)ifp)
257a254,256
> 	if (is->is_flags & ACEF_OACTIVE)
> 		return;
> 	is->is_flags |= ACEF_OACTIVE;
262,263c261,262
< 		ifp->if_flags |= IFF_OACTIVE;
< 		return (0);
---
> 		is->is_flags &= ~ACEF_OACTIVE;
> 		return;
266c265
< 	IF_DEQUEUE(&ifp->if_snd, m);
---
> 	IF_DEQUEUE(&is->is_if.if_snd, m);
269,270c268,269
< 		ifp->if_flags &= ~IFF_OACTIVE;
< 		return (0);
---
> 		is->is_flags &= ~ACEF_OACTIVE;
> 		return;
272c271
< 	len = aceput(txs->tx_data, m);
---
> 	len = aceput(unit, txs->tx_data, m);
288c287
< 	ifp->if_opackets++;
---
> 	is->is_if.if_opackets++;
293d291
< #undef is
311c309
< 			acestart(&is->is_if);
---
> 			acestart(unit);
328c326
< 		acestart(&is->is_if);
---
> 		acestart(unit);
407c405,406
< 	 * information to be at the front.
---
> 	 * information to be at the front, but we still have to drop
> 	 * the type and length which are at the front of any trailer data.
411a411,418
> 	if (off) {
> 		struct ifnet *ifp;
> 
> 		ifp = *(mtod(m, struct ifnet **));
> 		m->m_off += 2 * sizeof (u_short);
> 		m->m_len -= 2 * sizeof (u_short);
> 		*(mtod(m, struct ifnet **)) = ifp;
> 	}
449,452c456,459
<  * Routine to copy from mbuf chain to transmit buffer on the VERSAbus
<  * If packet size is less than the minimum legal size,
<  * the buffer is expanded.  We probably should zero out the extra
<  * bytes for security, but that would slow things down.
---
>  * Ethernet output routine.
>  * Encapsulate a packet of type family for the local net.
>  * Use trailer local net encapsulation if enough data in first
>  * packet leaves a multiple of 512 bytes of data in remainder.
454,457c461,464
< aceput(txbuf, m)
< 	char *txbuf;
< 	struct mbuf *m;
< #ifdef notdef
---
> aceoutput(ifp, m0, dst)
> 	struct ifnet *ifp;
> 	struct mbuf *m0;
> 	struct sockaddr *dst;
459,463c466,473
< 	register u_char *bp, *mcp;
< 	register short *s1, *s2;
< 	register u_int len;
< 	register struct mbuf *mp;
< 	int total;
---
> 	register struct ace_softc *is = &ace_softc[ifp->if_unit];
> 	register struct mbuf *m = m0;
> 	register struct ether_header *ace;
> 	register int off;
> 	struct mbuf *mcopy = (struct mbuf *)0;
> 	int type, s, error, usetrailers;
> 	u_char edst[6];
> 	struct in_addr idst;
465,475c475,497
< 	total = mp->m_pkthdr.len;
< 	bp = (u_char *)txbuf;
< 	for (mp = m; mp; mp = mp->m_next) {
< 		len = mp->m_len;
< 		if (len == 0)
< 			continue;
< 		mcp = mtod(mp, u_char *);
< 		if (((int)mcp & 01) && ((int)bp & 01)) {
< 			/* source & destination at odd addresses */
< 			movob(bp++, *mcp++);
< 			--len;
---
> 	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING)) {
> 		error = ENETDOWN;
> 		goto bad;
> 	}
> 	switch (dst->sa_family) {
> 
> #ifdef INET
> 	case AF_INET:
> 		idst = ((struct sockaddr_in *)dst)->sin_addr;
> 		if (!arpresolve(&is->is_ac, m, &idst, edst, &usetrailers))
> 			return (0);	/* if not yet resolved */
> 		if (!bcmp((caddr_t)edst, (caddr_t)etherbroadcastaddr,
> 		    sizeof (edst)))
> 			mcopy = m_copy(m, 0, (int)M_COPYALL);
> 		off = ntohs((u_short)mtod(m, struct ip *)->ip_len) - m->m_len;
> 		if (usetrailers && off > 0 && (off & 0x1ff) == 0 &&
> 		    m->m_off >= MMINOFF + 2 * sizeof (u_short)) {
> 			type = ETHERTYPE_TRAIL + (off>>9);
> 			m->m_off -= 2 * sizeof (u_short);
> 			m->m_len += 2 * sizeof (u_short);
> 			*mtod(m, u_short *) = htons((u_short)ETHERTYPE_IP);
> 			*(mtod(m, u_short *) + 1) = htons((u_short)m->m_len);
> 			goto gottrailertype;
477,478c499,520
< 		if (len > 1 && (((int)mcp & 01)==0) && (((int)bp & 01)==0)) {
< 			int l = len & 1;
---
> 		type = ETHERTYPE_IP;
> 		off = 0;
> 		goto gottype;
> #endif
> #ifdef NS
> 	case AF_NS:
>  		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
> 		    (caddr_t)edst, sizeof (edst));
> 		if (!bcmp((caddr_t)edst, (caddr_t)&ns_broadhost,sizeof(edst)))
> 			mcopy = m_copy(m, 0, (int)M_COPYALL);
> 		else if (!bcmp((caddr_t)edst, (caddr_t)&ns_thishost,
> 		    sizeof(edst)))
> 			return(looutput(&loif, m, dst));
> 		type = ETHERTYPE_NS;
> 		off = 0;
> 		goto gottype;
> #endif
> 	case AF_UNSPEC:
> 		ace = (struct ether_header *)dst->sa_data;
> 		bcopy((caddr_t)ace->ether_dhost, (caddr_t)edst, sizeof (edst));
> 		type = ace->ether_type;
> 		goto gottype;
480,487c522,551
< 			s1 = (short *)bp;
< 			s2 = (short *)mcp;
< 			len >>= 1;		/* count # of shorts */
< 			while (len-- != 0)
< 				movow(s1++, *s2++);
< 			len = l;		/* # remaining bytes */
< 			bp = (u_char *)s1;
< 			mcp = (u_char *)s2;
---
> 	default:
> 		log(LOG_ERR, "ace%d: can't handle af%d\n",
> 		    ifp->if_unit, dst->sa_family);
> 		error = EAFNOSUPPORT;
> 		goto bad;
> 	}
> 
> gottrailertype:
> 	/*
> 	 * Packet to be sent as trailer: move first packet
> 	 * (control information) to end of chain.
> 	 */
> 	while (m->m_next)
> 		m = m->m_next;
> 	m->m_next = m0;
> 	m = m0->m_next;
> 	m0->m_next = 0;
> 	m0 = m;
> 
> gottype:
> 	/*
> 	 * Add local net header.  If no space in first mbuf,
> 	 * allocate another.
> 	 */
> 	if (m->m_off > MMAXOFF ||
> 	    MMINOFF + sizeof (struct ether_header) > m->m_off) { 
> 		m = m_get(M_DONTWAIT, MT_HEADER);
> 		if (m == 0) {
> 			error = ENOBUFS;
> 			goto bad;
489,490c553,558
< 		while (len-- != 0)
< 			movob(bp++, *mcp++);
---
> 		m->m_next = m0;
> 		m->m_off = MMINOFF;
> 		m->m_len = sizeof (struct ether_header);
> 	} else {
> 		m->m_off -= sizeof (struct ether_header);
> 		m->m_len += sizeof (struct ether_header);
492,493c560,587
< 	m_freem(m);
< 	return (total);
---
> 	ace = mtod(m, struct ether_header *);
> 	bcopy((caddr_t)edst, (caddr_t)ace->ether_dhost, sizeof (edst));
> 	bcopy((caddr_t)is->is_addr, (caddr_t)ace->ether_shost,
> 	    sizeof (is->is_addr));
> 	ace->ether_type = htons((u_short)type);
> 
> 	/*
> 	 * Queue message on interface, and start output if interface
> 	 * not yet active.
> 	 */
> 	s = splimp();
> 	if (IF_QFULL(&ifp->if_snd)) {
> 		IF_DROP(&ifp->if_snd);
> 		error = ENOBUFS;
> 		goto qfull;
> 	}
> 	IF_ENQUEUE(&ifp->if_snd, m);
> 	splx(s);
> 	acestart(ifp->if_unit);
> 	return (mcopy ? looutput(&loif, mcopy, dst) : 0);
> qfull:
> 	m0 = m;
> 	splx(s);
> bad:
> 	m_freem(m0);
> 	if (mcopy)
> 		m_freem(mcopy);
> 	return (error);
495c589,600
< #else
---
> 
> /*
>  * Routine to copy from mbuf chain to transmit buffer on the VERSAbus
>  * If packet size is less than the minimum legal size,
>  * the buffer is expanded.  We probably should zero out the extra
>  * bytes for security, but that would slow things down.
>  */
> /*ARGSUSED*/
> aceput(unit, txbuf, m)
> 	int unit;
> 	char *txbuf;
> 	struct mbuf *m;
534d638
< #endif
541a646
> /*ARGSUSED*/
543c648
< aceget(rxbuf, totlen, off, ifp)
---
> aceget(rxbuf, totlen, off0, ifp)
545c650
< 	int totlen, off;
---
> 	int totlen, off0;
549d653
< 	register struct mbuf *m;
550a655
> 	register struct mbuf *m;
552,553c657
< 	int len;
< 	u_char *packet_end;
---
> 	int len, off = off0;
555,570c659
< 	rxbuf += sizeof (struct ether_header);
< 	cp = rxbuf;
< 	packet_end = cp + totlen;
< 	if (off) {
< 		off += 2 * sizeof(u_short);
< 		totlen -= 2 *sizeof(u_short);
< 		cp = rxbuf + off;
< 	}
< 
< 	MGETHDR(m, M_DONTWAIT, MT_DATA);
< 	if (m == 0)
< 		return (0);
< 	m->m_pkthdr.rcvif = ifp;
< 	m->m_pkthdr.len = totlen;
< 	m->m_len = MHLEN;
< 
---
> 	cp = rxbuf + sizeof (struct ether_header);
572,584c661,674
< 		if (top) {
< 			MGET(m, M_DONTWAIT, MT_DATA);
< 			if (m == 0) {
< 				m_freem(top);
< 				return (0);
< 			}
< 			m->m_len = MLEN;
< 		}
< 		len = min(totlen, (packet_end - cp));
< 		if (len >= MINCLSIZE) {
< 			MCLGET(m, M_DONTWAIT);
< 			if (m->m_flags & M_EXT)
< 				m->m_len = len = min(len, MCLBYTES);
---
> 		MGET(m, M_DONTWAIT, MT_DATA);
> 		if (m == 0)
> 			goto bad;
> 		if (off) {
> 			len = totlen - off;
> 			cp = rxbuf + sizeof (struct ether_header) + off;
> 		} else
> 			len = totlen;
> 		if (ifp)
> 			len += sizeof(ifp);
> 		if (len >= NBPG) {
> 			MCLGET(m);
> 			if (m->m_len == CLBYTES)
> 				m->m_len = len = MIN(len, CLBYTES);
586c676
< 				len = m->m_len;
---
> 				m->m_len = len = MIN(MLEN, len);
587a678,682
> 			m->m_len = len = MIN(MLEN, len);
> 			m->m_off = MMINOFF;
> 		}
> 		mcp = mtod(m, u_char *);
> 		if (ifp) {
589c684
< 			 * Place initial small packet/header at end of mbuf.
---
> 			 * Prepend interface pointer to first mbuf.
591,596c686,689
< 			if (len < m->m_len) {
< 				if (top == 0 && len + max_linkhdr <= m->m_len)
< 					m->m_data += max_linkhdr;
< 				m->m_len = len;
< 			} else
< 				len = m->m_len;
---
> 			*(mtod(m, struct ifnet **)) = ifp;
> 			mcp += sizeof(ifp);
> 			len -= sizeof(ifp);
> 			ifp = (struct ifnet *)0;
598d690
< 		mcp = mtod(m, u_char *);
624,626c716,725
< 		totlen -= len;
< 		if (cp == packet_end)
< 			cp = rxbuf;
---
> 		if (off == 0) {
> 			totlen -= len;
> 			continue;
> 		}
> 		off += len;
> 		if (off == totlen) {
> 			cp = rxbuf + sizeof (struct ether_header);
> 			off = 0;
> 			totlen = off0;
> 		}
628a728,730
> bad:
> 	m_freem(top);
> 	return (0);
670c772
< 		switch (ifa->ifa_addr->sa_family) {
---
> 		switch (ifa->ifa_addr.sa_family) {
diff -r src/sys/tahoeif/if_enp.c ../src/sys/tahoeif/if_enp.c
5,7d4
<  * This code is derived from software contributed to Berkeley by
<  * Computer Consoles Inc.
<  *
20c17
<  *	@(#)if_enp.c	7.5 (Berkeley) 4/22/89
---
>  *	@(#)if_enp.c	7.2 (Berkeley) 6/29/88
78c75
< int	enpinit(), enpioctl(), enpreset(), enpoutput(), enpstart();
---
> int	enpinit(), enpioctl(), enpreset(), enpoutput();
132,133c129
< 	ifp->if_output = ether_output;
< 	ifp->if_start = enpstart;
---
> 	ifp->if_output = enpoutput;
135c131
< 	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX;
---
> 	ifp->if_flags = IFF_BROADCAST;
194c190
< 		enpread(&enp_softc[unit], bcbp);
---
> 		(void) enpread(&enp_softc[unit], bcbp);
208a205
> 	register struct ifqueue *inq;
227c224
< 			return;
---
> 			goto setup;
231c228
< 			return;
---
> 			goto setup;
236c233
< 		return;
---
> 		goto setup;
241c238,239
< 	 * information to be at the front.
---
> 	 * information to be at the front, but we still have to drop
> 	 * the type and length which are at the front of any trailer data.
245,246c243,283
< 		return;
< 	ether_input(&es->es_if, enp, m);
---
> 		goto setup;
> 	if (off) {
> 		struct ifnet *ifp;
> 
> 		ifp = *(mtod(m, struct ifnet **));
> 		m->m_off += 2 * sizeof (u_short);
> 		m->m_len -= 2 * sizeof (u_short);
> 		*(mtod(m, struct ifnet **)) = ifp;
> 	}
> 	switch (enp->ether_type) {
> 
> #ifdef INET
> 	case ETHERTYPE_IP:
> 		schednetisr(NETISR_IP);
> 		inq = &ipintrq;
> 		break;
> #endif
> 	case ETHERTYPE_ARP:
> 		arpinput(&es->es_ac, m);
> 		goto setup;
> 
> #ifdef NS
> 	case ETHERTYPE_NS:
> 		schednetisr(NETISR_NS);
> 		inq = &nsintrq;
> 		break;
> #endif
> 	default:
> 		m_freem(m);
> 		goto setup;
> 	}
> 	if (IF_QFULL(inq)) {
> 		IF_DROP(inq);
> 		m_freem(m);
> 		goto setup;
> 	}
> 	s = splimp();
> 	IF_ENQUEUE(inq, m);
> 	splx(s);
> setup:
> 	return (0);
249c286,295
< enpstart(ifp)
---
> /*
>  * Ethernet output routine. (called by user)
>  * Encapsulate a packet of type family for the local net.
>  * Use trailer local net encapsulation if enough data in first
>  * packet leaves a multiple of 512 bytes of data in remainder.
>  * If destination is this address or broadcast, send packet to
>  * loop device to kludge around the fact that 3com interfaces can't
>  * talk to themselves.
>  */
> enpoutput(ifp, m0, dst)
250a297,298
> 	struct mbuf *m0;
> 	struct sockaddr *dst;
251a300,307
> 	register struct enp_softc *es = &enp_softc[ifp->if_unit];
> 	register struct mbuf *m = m0;
> 	register struct ether_header *enp;
> 	register int off;
> 	struct mbuf *mcopy = (struct mbuf *)0;
> 	int type, s, error, usetrailers;
> 	u_char edst[6];
> 	struct in_addr idst;
253,256c309,417
< 	if (enpput(ifp))
< 		return (ENOBUFS);
< 	else
< 		return (0);
---
> 	if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) != (IFF_UP|IFF_RUNNING)) {
> 		error = ENETDOWN;
> 		goto bad;
> 	}
> 	switch (dst->sa_family) {
> #ifdef INET
> 	case AF_INET:
> 		idst = ((struct sockaddr_in *)dst)->sin_addr;
> 		if (!arpresolve(&es->es_ac, m, &idst, edst, &usetrailers))
> 			return (0);	/* if not yet resolved */
> 		if (!bcmp((caddr_t)edst, (caddr_t)etherbroadcastaddr,
> 		    sizeof (edst)))
> 			mcopy = m_copy(m, 0, (int)M_COPYALL);
> 		off = ntohs((u_short)mtod(m, struct ip *)->ip_len) - m->m_len;
> 		if (usetrailers && off > 0 && (off & 0x1ff) == 0 &&
> 		    m->m_off >= MMINOFF + 2 * sizeof (u_short)) {
> 			type = ETHERTYPE_TRAIL + (off>>9);
> 			m->m_off -= 2 * sizeof (u_short);
> 			m->m_len += 2 * sizeof (u_short);
> 			*mtod(m, u_short *) = htons((u_short)ETHERTYPE_IP);
> 			*(mtod(m, u_short *) + 1) = htons((u_short)m->m_len);
> 			goto gottrailertype;
> 		}
> 		type = ETHERTYPE_IP;
> 		off = 0;
> 		goto gottype;
> #endif
> #ifdef NS
> 	case AF_NS:
> 		bcopy((caddr_t)&(((struct sockaddr_ns *)dst)->sns_addr.x_host),
> 		    (caddr_t)edst, sizeof (edst));
> 		if (!bcmp((caddr_t)edst, (caddr_t)&ns_broadhost, sizeof (edst)))
> 			mcopy = m_copy(m, 0, (int)M_COPYALL);
> 		else if (!bcmp((caddr_t)edst, (caddr_t)&ns_thishost,
> 		    sizeof (edst)))
> 			return (looutput(&loif, m, dst));
> 		type = ETHERTYPE_NS;
> 		off = 0;
> 		goto gottype;
> #endif
> 	case AF_UNSPEC:
> 		enp = (struct ether_header *)dst->sa_data;
> 		bcopy((caddr_t)enp->ether_dhost, (caddr_t)edst, sizeof (edst));
> 		type = enp->ether_type;
> 		goto gottype;
> 
> 	default:
> 		log(LOG_ERR, "enp%d: can't handle af%d\n",
> 		    ifp->if_unit, dst->sa_family);
> 		error = EAFNOSUPPORT;
> 		goto bad;
> 	}
> 
> gottrailertype:
> 	/*
> 	 * Packet to be sent as trailer: move first packet
> 	 * (control information) to end of chain.
> 	 */
> 	while (m->m_next)
> 		m = m->m_next;
> 	m->m_next = m0;
> 	m = m0->m_next;
> 	m0->m_next = 0;
> 	m0 = m;
> 
> gottype:
> 	/*
>          * Add local net header.  If no space in first mbuf,
>          * allocate another.
>          */
> 	if (m->m_off > MMAXOFF ||
> 	    MMINOFF + sizeof (struct ether_header) > m->m_off) {
> 		m = m_get(M_DONTWAIT, MT_HEADER);
> 		if (m == 0) {
> 			error = ENOBUFS;
> 			goto bad;
> 		}
> 		m->m_next = m0;
> 		m->m_off = MMINOFF;
> 		m->m_len = sizeof (struct ether_header);
> 	} else {
> 		m->m_off -= sizeof (struct ether_header);
> 		m->m_len += sizeof (struct ether_header);
> 	}
> 	enp = mtod(m, struct ether_header *);
> 	bcopy((caddr_t)edst, (caddr_t)enp->ether_dhost, sizeof (edst));
> 	bcopy((caddr_t)es->es_addr, (caddr_t)enp->ether_shost,
> 	    sizeof (es->es_addr));
> 	enp->ether_type = htons((u_short)type);
> 
> 	/*
> 	 * Queue message on interface if possible 
> 	 */
> 	s = splimp();	
> 	if (enpput(ifp->if_unit, m)) {
> 		error = ENOBUFS;
> 		goto qfull;
> 	}
> 	splx(s);	
> 	es->es_if.if_opackets++; 
> 	return (mcopy ? looutput(&loif, mcopy, dst) : 0);
> qfull:
> 	splx(s);	
> 	m0 = m;
> bad:
> 	m_freem(m0);
> 	if (mcopy)
> 		m_freem(mcopy);
> 	return (error);
262,263c423,425
< enpput(ifp)
< struct ifnet *ifp;
---
> enpput(unit, m)
> 	int unit;
> 	struct mbuf *m;
270,271c432
< 	int unit = ifp->if_unit, ret = 1;
< 	struct mbuf *m;
---
> 	u_char *mcp;
274,283c435,436
< again:
< 	if (ringempty((RING *)&addr->enp_hostfree))  {
< 	/*	ifp->if_flags |= IFF_OACTIVE; */
< 		return (ret);
< 	}
< 	IF_DEQUEUE(&ifp->if_snd, m);
< 	if (m == 0) {
< 		ifp->if_flags &= ~IFF_OACTIVE;
< 		return (0);
< 	}
---
> 	if (ringempty((RING *)&addr->enp_hostfree)) 
> 		return (1);	
291c444,445
< 		enpcopy(mtod(mp, u_char *), bp, len);
---
> 		mcp = mtod(mp, u_char *);
> 		enpcopy(mcp, bp, len);
295c449
< 	bcbp->b_len = max(ETHERMIN+sizeof (struct ether_header), bcbp->b_len);
---
> 	bcbp->b_len = MAX(ETHERMIN+sizeof (struct ether_header), bcbp->b_len);
300,301c454
< 	ret = 0;
< 	goto again;
---
> 	return (0);
311c464
< enpget(rxbuf, totlen, off, ifp)
---
> enpget(rxbuf, totlen, off0, ifp)
313c466
< 	int totlen, off;
---
> 	int totlen, off0;
316c469
< 	register u_char *cp;
---
> 	register u_char *cp, *mcp;
319,320c472
< 	int len;
< 	u_char *packet_end;
---
> 	int len, off = off0;
322,337c474
< 	rxbuf += sizeof (struct ether_header);
< 	cp = rxbuf;
< 	packet_end = cp + totlen;
< 	if (off) {
< 		off += 2 * sizeof(u_short);
< 		totlen -= 2 *sizeof(u_short);
< 		cp = rxbuf + off;
< 	}
< 
< 	MGETHDR(m, M_DONTWAIT, MT_DATA);
< 	if (m == 0)
< 		return (0);
< 	m->m_pkthdr.rcvif = ifp;
< 	m->m_pkthdr.len = totlen;
< 	m->m_len = MHLEN;
< 
---
> 	cp = rxbuf + sizeof (struct ether_header);
339,351c476,487
< 		if (top) {
< 			MGET(m, M_DONTWAIT, MT_DATA);
< 			if (m == 0) {
< 				m_freem(top);
< 				return (0);
< 			}
< 			m->m_len = MLEN;
< 		}
< 		len = min(totlen, (packet_end - cp));
< 		if (len >= MINCLSIZE) {
< 			MCLGET(m, M_DONTWAIT);
< 			if (m->m_flags & M_EXT)
< 				m->m_len = len = min(len, MCLBYTES);
---
> 		MGET(m, M_DONTWAIT, MT_DATA);
> 		if (m == 0) 
> 			goto bad;
> 		if (off) {
> 			len = totlen - off;
> 			cp = rxbuf + sizeof (struct ether_header) + off;
> 		} else
> 			len = totlen;
> 		if (len >= NBPG) {
> 			MCLGET(m);
> 			if (m->m_len == CLBYTES)
> 				m->m_len = len = MIN(len, CLBYTES);
353c489
< 				len = m->m_len;
---
> 				m->m_len = len = MIN(MLEN, len);
354a491,495
> 			m->m_len = len = MIN(MLEN, len);
> 			m->m_off = MMINOFF;
> 		}
> 		mcp = mtod(m, u_char *);
> 		if (ifp) {
356c497
< 			 * Place initial small packet/header at end of mbuf.
---
> 			 * Prepend interface pointer to first mbuf.
358,363c499,502
< 			if (len < m->m_len) {
< 				if (top == 0 && len + max_linkhdr <= m->m_len)
< 					m->m_data += max_linkhdr;
< 				m->m_len = len;
< 			} else
< 				len = m->m_len;
---
> 			*(mtod(m, struct ifnet **)) = ifp;
> 			mcp += sizeof (ifp);
> 			len -= sizeof (ifp);
> 			ifp = (struct ifnet *)0;
365c504,505
< 		enpcopy(cp, mtod(m, u_char *), (u_int)len);
---
> 		enpcopy(cp, mcp, (u_int)len);
> 		cp += len;
368,371c508,517
< 		totlen -= len;
< 		cp += len;
< 		if (cp == packet_end)
< 			cp = rxbuf;
---
> 		if (off == 0) {
> 			totlen -= len;
> 			continue;
> 		}
> 		off += len;
> 		if (off == totlen) {
> 			cp = rxbuf + sizeof (struct ether_header);
> 			off = 0;
> 			totlen = off0;
> 		}
373a520,522
> bad:
> 	m_freem(top);
> 	return (0);
420c569
< 		switch (ifa->ifa_addr->sa_family) {
---
> 		switch (ifa->ifa_addr.sa_family) {
Only in src/sys/tahoeif: if_ex.c
Only in src/sys/tahoeif: if_exreg.h
diff -r src/sys/tahoestand/Makefile ../src/sys/tahoestand/Makefile
17c17
< #	@(#)Makefile	7.10 (Berkeley) 5/1/89
---
> #	@(#)Makefile	7.9 (Berkeley) 7/9/88
36,37c36,37
< 	srt0.c sys.c vd.c cy.c hd.c
< DRIVERS=cy.o vd.o hd.o
---
> 	srt0.c sys.c vd.c cy.c hdc.c
> DRIVERS=cy.o vd.o hdc.o
42c42
< ${SUBDIR}:
---
> ${SUBDIR}: FRC
97c97
< clean:
---
> clean: FRC
101,105c101
< cleandir: clean
< 	rm -f ${MAN} tags .depend
< 	for i in ${SUBDIR}; do (cd $$i; make ${MFLAGS} cleandir); done
< 
< depend: ${SRCS}
---
> depend: ${SRCS} FRC
109c105
< install:
---
> install: FRC
116,118c112,114
< #	for i in ${SUBDIR}; do \
< #		(cd $$i; make ${MFLAGS} DESTDIR=${DESTDIR} install) \
< #	done
---
> 	for i in ${SUBDIR}; do \
> 		(cd $$i; make ${MFLAGS} DESTDIR=${DESTDIR} install) \
> 	done
120c116
< tags: ${SRCS}
---
> tags: ${SRCS} FRC
122a119,179
> 
> FRC:
> 
> # DO NOT DELETE THIS LINE -- mkdep uses it.
> # DO NOT PUT ANYTHING AFTER THIS LINE, IT WILL GO AWAY.
> 
> boot.o: boot.c ../machine/mtpr.h ../h/param.h /usr/include/sys/types.h
> boot.o: ../h/signal.h /usr/include/machine/trap.h
> boot.o: /usr/include/machine/machparam.h /usr/include/machine/endian.h
> boot.o: ../h/inode.h ../h/fs.h ../h/vm.h /usr/include/sys/vmparam.h
> boot.o: /usr/include/machine/vmparam.h /usr/include/sys/vmmac.h
> boot.o: /usr/include/sys/vmmeter.h /usr/include/sys/vmsystm.h ../stand/saio.h
> boot.o: ../stand/saioctl.h ../stand/saerrno.h ../h/reboot.h
> boot.o: /usr/include/a.out.h /usr/include/sys/exec.h
> cat.o: ../stand/cat.c
> conf.o: conf.c ../h/param.h /usr/include/sys/types.h ../h/signal.h
> conf.o: /usr/include/machine/trap.h /usr/include/machine/machparam.h
> conf.o: /usr/include/machine/endian.h ../h/inode.h ../h/fs.h ../stand/saio.h
> conf.o: ../stand/saioctl.h ../stand/saerrno.h
> copy.o: ../stand/copy.c
> dev.o: ../stand/dev.c ../h/param.h /usr/include/sys/types.h ../h/signal.h
> dev.o: /usr/include/machine/trap.h /usr/include/machine/machparam.h
> dev.o: /usr/include/machine/endian.h ../h/inode.h ../h/fs.h ../stand/saio.h
> dev.o: ../stand/saioctl.h ../stand/saerrno.h
> getfile.o: ../stand/getfile.c ../h/param.h /usr/include/sys/types.h
> getfile.o: ../h/signal.h /usr/include/machine/trap.h
> getfile.o: /usr/include/machine/machparam.h /usr/include/machine/endian.h
> getfile.o: ../h/inode.h ../h/fs.h ../stand/saio.h ../stand/saioctl.h
> getfile.o: ../stand/saerrno.h
> gets.o: ../stand/gets.c
> ls.o: ../stand/ls.c ../h/param.h /usr/include/sys/types.h ../h/signal.h
> ls.o: /usr/include/machine/trap.h /usr/include/machine/machparam.h
> ls.o: /usr/include/machine/endian.h ../h/inode.h ../h/dir.h ../h/fs.h
> ls.o: ../stand/saio.h ../stand/saioctl.h ../stand/saerrno.h
> prf.o: prf.c ../machine/mtpr.h ../h/param.h /usr/include/sys/types.h
> prf.o: ../h/signal.h /usr/include/machine/trap.h
> prf.o: /usr/include/machine/machparam.h /usr/include/machine/endian.h
> prf.o: ../tahoe/cp.h
> srt0.o: srt0.c ../machine/mtpr.h
> sys.o: ../stand/sys.c ../h/param.h /usr/include/sys/types.h ../h/signal.h
> sys.o: /usr/include/machine/trap.h /usr/include/machine/machparam.h
> sys.o: /usr/include/machine/endian.h ../h/inode.h ../h/fs.h ../h/dir.h
> sys.o: ../h/reboot.h ../stand/saio.h ../stand/saioctl.h ../stand/saerrno.h
> vd.o: vd.c ../machine/mtpr.h ../h/param.h /usr/include/sys/types.h
> vd.o: ../h/signal.h /usr/include/machine/trap.h
> vd.o: /usr/include/machine/machparam.h /usr/include/machine/endian.h
> vd.o: ../h/inode.h ../h/fs.h ../h/buf.h ../h/disklabel.h ../stand/saio.h
> vd.o: ../stand/saioctl.h ../stand/saerrno.h ../tahoevba/vdreg.h
> vd.o: ../tahoevba/vbaparam.h
> cy.o: cy.c ../machine/pte.h ../machine/mtpr.h ../h/param.h
> cy.o: /usr/include/sys/types.h ../h/signal.h /usr/include/machine/trap.h
> cy.o: /usr/include/machine/machparam.h /usr/include/machine/endian.h
> cy.o: ../h/inode.h ../h/fs.h ../stand/saio.h ../stand/saioctl.h
> cy.o: ../stand/saerrno.h ../tahoevba/cyreg.h ../tahoevba/vbaparam.h
> hdc.o: hdc.c /usr/include/machine/mtpr.h ../h/param.h ../h/types.h
> hdc.o: ../h/signal.h /usr/include/machine/trap.h ../h/../machine/machparam.h
> hdc.o: /usr/include/machine/endian.h ../h/inode.h ../h/fs.h ../h/buf.h
> hdc.o: ../h/ioctl.h ../h/ttychars.h ../h/ttydev.h ../h/disklabel.h
> hdc.o: ../stand/saio.h ../stand/saioctl.h ../stand/saerrno.h ../tahoevba/hdc.h
> 
> # IF YOU PUT ANYTHING HERE IT WILL GO AWAY
Only in src/sys/tahoestand: boot
diff -r src/sys/tahoestand/boot.c ../src/sys/tahoestand/boot.c
1c1
< /*	boot.c	7.1	89/05/01	*/
---
> /*	boot.c	1.7	88/03/04	*/
3c3
< #include "machine/mtpr.h"
---
> #include "../machine/mtpr.h"
31c31
< 	int io = 0, retry, type;
---
> 	int io, retry, type;
38a39
> 	printf("\nBoot\n");
51,52d51
< 		if (io >= 0)
< 			printf("\nBoot");
82,83c81,84
< 	if (read(io, (char *)&x, sizeof(x)) != sizeof(x) || N_BADMAG(x)) {
< 		printf("bad magic #\n");
---
> 	i = read(io, (char *)&x, sizeof x);
> 	if (i != sizeof x ||
> 	    (x.a_magic != 0407 && x.a_magic != 0413 && x.a_magic != 0410)) {
> 		printf("Bad format\n");
86,87c87,88
< 	printf("%ld", x.a_text);
< 	if (x.a_magic == ZMAGIC && lseek(io, 0x400, 0) == -1)
---
> 	printf("%d", x.a_text);
> 	if (x.a_magic == 0413 && lseek(io, 0x400, 0) == -1)
92c93
< 	if (x.a_magic == ZMAGIC || x.a_magic == NMAGIC)
---
> 	if (x.a_magic == 0413 || x.a_magic == 0410)
95c96
< 	printf("+%ld", x.a_data);
---
> 	printf("+%d", x.a_data);
99c100
< 	printf("+%ld", x.a_bss);
---
> 	printf("+%d", x.a_bss);
105c106
< 		printf("[+%ld", x.a_syms);
---
> 		printf("[+%d", x.a_syms);
125c126
< 	printf(" start 0x%lx\n", x.a_entry);
---
> 	printf(" start 0x%x\n", x.a_entry);
132c133
< 	printf("short read\n");
---
> 	printf("Short read\n");
Only in src/sys/tahoestand: boot.o
Only in src/sys/tahoestand: bootsrt0.o
Only in src/sys/tahoestand: cat
Only in src/sys/tahoestand: cat.o
Only in src/sys/tahoestand: conf.o
Only in src/sys/tahoestand: copy
Only in src/sys/tahoestand: copy.o
diff -r src/sys/tahoestand/cy.c ../src/sys/tahoestand/cy.c
1c1
< /*	cy.c	7.8	89/04/25	*/
---
> /*	cy.c	7.7	88/05/24	*/
6,7c6,7
< #include "machine/pte.h"
< #include "machine/mtpr.h"
---
> #include "../machine/pte.h"
> #include "../machine/mtpr.h"
Only in src/sys/tahoestand: cy.o
Only in src/sys/tahoestand: dev.o
Only in src/sys/tahoestand: getfile.o
Only in src/sys/tahoestand: gets.o
Only in src/sys/tahoestand: hd.c
Only in src/sys/tahoestand: hd.o
Only in ../src/sys/tahoestand: hdc.c
Only in src/sys/tahoestand: libsa.a
Only in src/sys/tahoestand: ls
Only in src/sys/tahoestand: ls.o
Only in src/sys/tahoestand: machdep.o
Only in src/sys/tahoestand: ncy.c
Only in src/sys/tahoestand: ncy.o
diff -r src/sys/tahoestand/prf.c ../src/sys/tahoestand/prf.c
1c1
< /*	prf.c	1.5	89/04/25	*/
---
> /*	prf.c	1.4	88/03/03	*/
4c4
< #include "machine/mtpr.h"
---
> #include "../machine/mtpr.h"
Only in src/sys/tahoestand: prf.o
Only in src/sys/tahoestand: printn.o
diff -r src/sys/tahoestand/srt0.c ../src/sys/tahoestand/srt0.c
1c1
< /*	srt0.c	1.7	89/04/25	*/
---
> /*	srt0.c	1.6	87/04/02	*/
3c3
< #include "machine/mtpr.h"
---
> #include "../machine/mtpr.h"
Only in src/sys/tahoestand: srt0.o
Only in src/sys/tahoestand: sys.o
diff -r src/sys/tahoestand/vd.c ../src/sys/tahoestand/vd.c
1,21c1
< /*
<  * Copyright (c) 1988 The Regents of the University of California.
<  * All rights reserved.
<  *
<  * This code is derived from software contributed to Berkeley by
<  * Computer Consoles Inc.
<  *
<  * Redistribution and use in source and binary forms are permitted
<  * provided that the above copyright notice and this paragraph are
<  * duplicated in all such forms and that any documentation,
<  * advertising materials, and other materials related to such
<  * distribution and use acknowledge that the software was developed
<  * by the University of California, Berkeley.  The name of the
<  * University may not be used to endorse or promote products derived
<  * from this software without specific prior written permission.
<  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
<  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
<  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
<  *
<  *	@(#)vd.c	7.13 (Berkeley) 4/25/89
<  */
---
> /*	vd.c	7.10	88/06/14	*/
26c6
< #include "machine/mtpr.h"
---
> #include "../machine/mtpr.h"
Only in src/sys/tahoestand: vd.o
Only in src/sys/tahoestand/vdformat: Errs
diff -r src/sys/tahoestand/vdformat/Makefile ../src/sys/tahoestand/vdformat/Makefile
17c17
< #	@(#)Makefile	1.10 (Berkeley) 10/28/88
---
> #	@(#)Makefile	1.8 (Berkeley) 7/9/88
32d31
< MAN=	vdformat.0
42,44d40
< cleandir: clean
< 	rm -f ${MAN} tags .depend
< 
51c47
< install: ${MAN}
---
> install:
53d48
< 	install -o bin -g bin -m 444 ${MAN} ${DESTDIR}/usr/man/cat8/tahoe
55c50
< depend: ${SRCS}
---
> depend:
58c53
< tags: ${SRCS}
---
> tags:
59a55,186
> 
> # DO NOT DELETE THIS LINE -- mkdep uses it.
> # DO NOT PUT ANYTHING AFTER THIS LINE, IT WILL GO AWAY.
> 
> cmd.o: cmd.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h ../../h/param.h
> cmd.o: /usr/include/sys/types.h ../../h/signal.h ../../machine/trap.h
> cmd.o: ../../machine/machparam.h ../../h/buf.h ../../h/disklabel.h
> cmd.o: ../../h/inode.h ../../h/fs.h ../../tahoevba/vbaparam.h
> cmd.o: ../../tahoevba/vdreg.h ../../tahoe/cp.h cmd.h
> cons.o: cons.c ../../h/../machine/mtpr.h ../../h/param.h
> cons.o: /usr/include/sys/types.h ../../h/signal.h ../../machine/trap.h
> cons.o: ../../machine/machparam.h ../../h/../tahoe/cp.h
> config.o: config.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> config.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> config.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> config.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> config.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> correct.o: correct.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> correct.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> correct.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> correct.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> correct.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> correct.o: cmd.h
> delete.o: delete.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> delete.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> delete.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> delete.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> delete.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> delete.o: cmd.h
> disklabel.o: disklabel.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> disklabel.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> disklabel.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> disklabel.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> disklabel.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> disklabel.o: cmd.h
> exercise.o: exercise.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> exercise.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> exercise.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> exercise.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> exercise.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> help.o: help.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h ../../h/param.h
> help.o: /usr/include/sys/types.h ../../h/signal.h ../../machine/trap.h
> help.o: ../../machine/machparam.h ../../h/buf.h ../../h/disklabel.h
> help.o: ../../h/inode.h ../../h/fs.h ../../tahoevba/vbaparam.h
> help.o: ../../tahoevba/vdreg.h ../../tahoe/cp.h cmd.h
> format.o: format.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> format.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> format.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> format.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> format.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> info.o: info.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h ../../h/param.h
> info.o: /usr/include/sys/types.h ../../h/signal.h ../../machine/trap.h
> info.o: ../../machine/machparam.h ../../h/buf.h ../../h/disklabel.h
> info.o: ../../h/inode.h ../../h/fs.h ../../tahoevba/vbaparam.h
> info.o: ../../tahoevba/vdreg.h ../../tahoe/cp.h
> io.o: io.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h ../../h/param.h
> io.o: /usr/include/sys/types.h ../../h/signal.h ../../machine/trap.h
> io.o: ../../machine/machparam.h ../../h/buf.h ../../h/disklabel.h
> io.o: ../../h/inode.h ../../h/fs.h ../../tahoevba/vbaparam.h
> io.o: ../../tahoevba/vdreg.h ../../tahoe/cp.h cmd.h
> list.o: list.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h ../../h/param.h
> list.o: /usr/include/sys/types.h ../../h/signal.h ../../machine/trap.h
> list.o: ../../machine/machparam.h ../../h/buf.h ../../h/disklabel.h
> list.o: ../../h/inode.h ../../h/fs.h ../../tahoevba/vbaparam.h
> list.o: ../../tahoevba/vdreg.h ../../tahoe/cp.h
> maps.o: maps.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h ../../h/param.h
> maps.o: /usr/include/sys/types.h ../../h/signal.h ../../machine/trap.h
> maps.o: ../../machine/machparam.h ../../h/buf.h ../../h/disklabel.h
> maps.o: ../../h/inode.h ../../h/fs.h ../../tahoevba/vbaparam.h
> maps.o: ../../tahoevba/vdreg.h ../../tahoe/cp.h
> proc_cmd.o: proc_cmd.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> proc_cmd.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> proc_cmd.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> proc_cmd.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> proc_cmd.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> proc_cmd.o: cmd.h
> profile.o: profile.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> profile.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> profile.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> profile.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> profile.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> relocate.o: relocate.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> relocate.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> relocate.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> relocate.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> relocate.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> relocate.o: cmd.h
> reset.o: reset.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> reset.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> reset.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> reset.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> reset.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> smd.o: smd.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h ../../h/param.h
> smd.o: /usr/include/sys/types.h ../../h/signal.h ../../machine/trap.h
> smd.o: ../../machine/machparam.h ../../h/buf.h ../../h/disklabel.h
> smd.o: ../../h/inode.h ../../h/fs.h ../../tahoevba/vbaparam.h
> smd.o: ../../tahoevba/vdreg.h ../../tahoe/cp.h
> smd_e.o: smd_e.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> smd_e.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> smd_e.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> smd_e.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> smd_e.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> start.o: start.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> start.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> start.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> start.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> start.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> status.o: status.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> status.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> status.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> status.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> status.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> strpbrk.o: strpbrk.c
> strspn.o: strspn.c
> strtok.o: strtok.c
> util.o: util.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h ../../h/param.h
> util.o: /usr/include/sys/types.h ../../h/signal.h ../../machine/trap.h
> util.o: ../../machine/machparam.h ../../h/buf.h ../../h/disklabel.h
> util.o: ../../h/inode.h ../../h/fs.h ../../tahoevba/vbaparam.h
> util.o: ../../tahoevba/vdreg.h ../../tahoe/cp.h cmd.h
> vdfmt.o: vdfmt.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> vdfmt.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> vdfmt.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> vdfmt.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> vdfmt.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> verify.o: verify.c vdfmt.h /usr/include/setjmp.h ../../tahoe/mtpr.h
> verify.o: ../../h/param.h /usr/include/sys/types.h ../../h/signal.h
> verify.o: ../../machine/trap.h ../../machine/machparam.h ../../h/buf.h
> verify.o: ../../h/disklabel.h ../../h/inode.h ../../h/fs.h
> verify.o: ../../tahoevba/vbaparam.h ../../tahoevba/vdreg.h ../../tahoe/cp.h
> 
> # IF YOU PUT ANYTHING HERE IT WILL GO AWAY
diff -r src/sys/tahoestand/vdformat/cons.c ../src/sys/tahoestand/vdformat/cons.c
1c1
< /*	cons.c	1.2	89/04/25	*/
---
> /*	cons.c	1.1	88/06/02	*/
7c7
< #include "machine/mtpr.h"
---
> #include "../machine/mtpr.h"
diff -r src/sys/tahoestand/vdformat/disklabel.c ../src/sys/tahoestand/vdformat/disklabel.c
2c2
< static char sccsid[] = "%W% (Berkeley/CCI) %G%";
---
> static char sccsid[] = "@(#)disklabel.c	1.2 (Berkeley/CCI) 6/7/88";
69c69
< 	while (lp->d_traksize == 0) {
---
> 	while (op_mask & FORMAT_OP && lp->d_traksize == 0) {
diff -r src/sys/tahoestand/vdformat/format.c ../src/sys/tahoestand/vdformat/format.c
37d36
< #ifdef notdef
47d45
< #endif
51d48
< #ifdef notdef
56d52
< #endif
94d89
< 	/*
96,97c91
< 	*/
< 		dskaddr.cylinder = 84;
---
> 		dskaddr.cylinder = cyl;
101d94
< 	/*
103d95
< 	*/
164c156
< 	dcb.devselect = (char)cur.drive | lab->d_devflags;
---
> 	dcb.devselect = (char)cur.drive;
167d158
< printf("format %d @ %d/%d/%d\n", count, dskaddr->cylinder, dskaddr->track, dskaddr->sector);
Only in src/sys/tahoestand/vdformat: format.c.save
diff -r src/sys/tahoestand/vdformat/info.c ../src/sys/tahoestand/vdformat/info.c
2c2
< static char sccsid[] = "%W% (Berkeley/CCI) %G%";
---
> static char sccsid[] = "@(#)info.c	1.2 (Berkeley/CCI) 11/23/87";
21,22c21,23
< 	if(has_map == true) {
< 		print("Module serial number is %d.\n", bad_map->bs_id);
---
> 	print("Module serial number is %d.\n", bad_map->bs_id);
> 	print("Drive type is %s.\n", lab->d_typename);
> 	if(has_map == true)
24c25
< 	} else
---
> 	else
diff -r src/sys/tahoestand/vdformat/maps.c ../src/sys/tahoestand/vdformat/maps.c
2c2
< static char sccsid[] = "%W% (Berkeley/CCI) %G%";
---
> static char sccsid[] = "@(#)maps.c	1.7 (Berkeley/CCI) 6/7/88";
42d41
< 	bs_map	*map;
45d43
< 	bs_map_space.bs_magic = BSMAGIC;
46a45,46
> 	for(i=0; i < 100; i++)
> 		scratch[i] = -1;
50,51c50,51
< 		if(access_dsk((char *)bs_map_space.space,
< 		    &dskaddr, VDOP_RD, lab->d_nsectors, 1) & VDERR_HARD)
---
> 		if(access_dsk((char *)save,&dskaddr, VDOP_RD,
> 		    lab->d_nsectors,1)& VDERR_HARD)
53,65c53,54
< 		bad_map = (bs_map *)bs_map_space.space;
< 		/*
< 		 * If this doesn't look like a new-style map,
< 		 * but (as an old-style map) bs_count and bs_max are sensible,
< 		 * munge pointer to prepend fields missing in old map.
< 		 */
< 		if (bad_map->bs_magic != BSMAGIC &&
< 		    bad_map->bs_cksum <= MAX_FLAWMAP(bytes_trk) /* bs_count */
< 		    && bad_map->bs_id <= MAX_FLAWMAP(bytes_trk)) /* bs_max */
< 			bad_map = (bs_map *)&bs_map_space;
< 		if (trk > 0 && 
< 		    bcmp((char *)bs_map_space.space,
< 			(char *)save, bytes_trk) == 0) {
---
> 		if(bcmp((char *)scratch, (char *)save, bytes_trk) == true) {
> 			bcopy((char *)save, (char *)bad_map, bytes_trk);
82a72,74
> 			bzero(bad_map, bytes_trk);
> 			bad_map->bs_id = 0;
> 			bad_map->bs_max = MAX_FLAWS;
84c76
< 		bcopy((char *)bs_map_space.space, (char *)save, bytes_trk);
---
> 		bcopy((char *)save, (char *)scratch, bytes_trk);
86,90d77
< 	bad_map = (bs_map *)bs_map_space.space;
< 	bzero(bad_map, bytes_trk);
< 	bad_map->bs_magic = BSMAGIC;
< 	bad_map->bs_id = 0;
< 	bad_map->bs_max = MAX_FLAWS;
108d94
< 	bad_map->bs_magic = BSMAGIC;
292c278
< 			bcopy((char *)bad_map + (sec * lab->d_secsize),
---
> 			bcopy((char *)bs_map_space + (sec * lab->d_secsize),
524,526d509
< 	if(bad_map->bs_magic != BSMAGIC)
< 		print("Bad-sector map magic number wrong! (%x != %x)\n",
< 		    bad_map->bs_magic, BSMAGIC);
531,533c514,516
< 	print("The following %d sector%s known to be bad:\n",
< 	    bad_map->bs_count, (bad_map->bs_count == 1) ? " is" : "s are");
< 	exdent(0);
---
> 	print("The following sector%s known to be bad:\n",
> 	    (bad_map->bs_count == 1) ? " is" : "s are");
> 	indent();
536,537c519,520
< 		print("%c %d cn %d tn %d sn %d pos %d len %d ",
< 			errloc.err_stat & HEADER_ERROR ? 'T' : 'S',
---
> 		print("%s %d cn %d tn %d sn %d pos %d len %d ",
> 			errloc.err_stat & HEADER_ERROR ? "Track@" : "Sector",
557a541
> 	exdent(1);
Only in src/sys/tahoestand/vdformat: old
Only in src/sys/tahoestand/vdformat: online
diff -r src/sys/tahoestand/vdformat/relocate.c ../src/sys/tahoestand/vdformat/relocate.c
2c2
< static char sccsid[] = "%W% (Berkeley/CCI) %G%";
---
> static char sccsid[] = "@(#)relocate.c	1.6 (Berkeley/CCI) 6/7/88";
73c73
< 	dskaddr.track = lab->d_ntracks - 1;
---
> 	dskaddr.cylinder = lab->d_ntracks - 1;
diff -r src/sys/tahoestand/vdformat/vdfmt.c ../src/sys/tahoestand/vdformat/vdfmt.c
2c2
< static char sccsid[] = "%W% (Berkeley/CCI) %G%";
---
> static char sccsid[] = "@(#)vdfmt.c	1.6 (Berkeley/CCI) 6/7/88";
14c14
< 	print("VDFORMAT            Berkeley Version %I% \n\n");
---
> 	print("VDFORMAT            Berkeley Version 1.6 \n\n");
172c172
< 	bad_map = (bs_map *)bs_map_space.space;
---
> 	bad_map = (bs_map *)bs_map_space;
diff -r src/sys/tahoestand/vdformat/vdfmt.h ../src/sys/tahoestand/vdformat/vdfmt.h
1c1
< /*	%M%	%I%	%E%	*/
---
> /*	vdfmt.h	1.7	88/06/07	*/
219,220d218
< 	unsigned int	bs_magic;	/* magic (0x12344321) */
< 	unsigned int	bs_cksum;	/* checksum (0) */
227,229c225
< #define MAX_FLAWMAP(x)	(((x) - sizeof(bs_map)) / sizeof(bs_entry))
< #define MAX_FLAWS	MAX_FLAWMAP(MAXTRKSIZ*sizeof(long))
< #define BSMAGIC		0x12344321
---
> #define MAX_FLAWS (((MAXTRKSIZ*sizeof(long))-sizeof(bs_map))/sizeof(bs_entry))
231,235c227
< struct {
< 	unsigned int	bs_magic;	/* magic (0x12344321) */
< 	unsigned int	bs_cksum;	/* checksum (0) */
< 	long	space[MAXTRKSIZ];
< } bs_map_space;
---
> long	bs_map_space[MAXTRKSIZ];
Only in src/sys/tahoestand/vdformat: vdformat.8
Only in src/sys/tahoevba: hd.c
Only in src/sys/tahoevba: hdreg.h
diff -r src/sys/tahoevba/vba.c ../src/sys/tahoevba/vba.c
17c17
<  *	@(#)vba.c	7.4 (Berkeley) 5/5/89
---
>  *	@(#)vba.c	7.2 (Berkeley) 6/29/88
27a28
> #include "dir.h"
31d31
< #include "dir.h"
233c233
<  * This code belongs half-way between {hd,vd}.c and this file.
---
>  * This code belongs half-way between vd.c and this file.
235,237d234
< 
< #include "dk.h"
< #if NVD > 0
240c237
< vd_sgsetup(bp, vb, sg)
---
> vba_sgsetup(bp, vb, sg)
249a247
> 	o = (int)bp->b_un.b_addr & PGOFSET;
261d258
< 	o = (int)bp->b_un.b_addr & PGOFSET;
263c260
< 	sg->start_addr.wcount = i >> 1;
---
> 	sg->start_addr.wcount = (i + 1) >> 1;
268c265
< 	i = i >> 1;
---
> 	i = (i + 1) >> 1;
277,324d273
< #endif
< 
< #include "hd.h"
< #if NHD > 0
< #include "hdreg.h"
< 
< hd_sgsetup(bp, vb, sg)
< 	register struct buf *bp;
< 	struct vb_buf *vb;
< 	struct chain *sg;
< {
< 	register struct pte *spte;
< 	register struct addr_chain *adr;
< 	register int i, cnt;
< 	int o;
< 
< 	if (bp->b_bcount > HDC_MAXBC ||
< 	    bp->b_bcount % sizeof(long) - 1 ||
< 	    (u_int)bp->b_un.b_addr % sizeof(long) - 1)
< 		return(0);
< 
< 	vb->vb_iskernel = (((int)bp->b_un.b_addr & KERNBASE) == KERNBASE);
< 	vb->vb_copy = 0;
< 	if (vb->vb_iskernel) {
< 		spte = kvtopte(bp->b_un.b_addr);
< 		vbastat.k_sg++;
< 	} else {
< 		spte = vtopte((bp->b_flags&B_DIRTY) ? &proc[2] : bp->b_proc,
< 		    btop(bp->b_un.b_addr));
< 		vbastat.u_sg++;
< 	}
< 
< 	o = (int)bp->b_un.b_addr & PGOFSET;
< 	i = min(NBPG - o, bp->b_bcount);
< 	sg->wcount = i >> 2;
< 	sg->memadr = ((spte++)->pg_pfnum << PGSHIFT) + o;
< 	cnt = 0;
< 	for (i = (bp->b_bcount - i) >> 2; i > 0; i -= NBPG / sizeof(long)) {
< 		if (++cnt == HDC_MAXCHAIN)
< 			return(0);
< 		sg->wcount |= LWC_DATA_CHAIN;
< 		++sg;
< 		sg->wcount = imin(i, NBPG / sizeof(long));
< 		sg->memadr = (spte++)->pg_pfnum << PGSHIFT;
< 	}
< 	return(1);
< }
< #endif
diff -r src/sys/tahoevba/vx.c ../src/sys/tahoevba/vx.c
50d49
< #include "../tahoevba/vbaparam.h"
120c119
< 	register struct vxdevice *vp;
---
> 	register struct vxdevice *vp = (struct vxdevice *)reg;
122d120
< 	struct pte *dummypte;
128,132d125
< 	if (!VBIOMAPPED(reg) && !vbmemalloc(16, reg, &dummypte, &reg)) {
< 		printf("vx%d: vbmemalloc failed.\n", vi->ui_unit);
< 		return(0);
< 	}
< 	vp = (struct vxdevice *)reg;
135,136d127
< printf("vx%d: %x\n", vi->ui_unit, reg);
< 	vi->ui_addr = reg;
Only in src/sys/tahoevba: vx.c.1
Only in src/sys/tahoevba: vx.c.okeeffe
